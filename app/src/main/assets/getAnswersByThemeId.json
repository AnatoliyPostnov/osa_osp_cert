[
  {
    "theme_id": 1,
    "theme_content": "Declarations and Access Control",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [3],
        "explanation": "1 is incorrect because classes implement interfaces, they don't extend them. 2 is incorrect because interfaces only \"inherit from\" other interfaces. 4 is incorrect based on the preceding rules."
      },
      {
        "question_id": 2,
        "correct_answers": [2, 6],
        "explanation": "2 and 6 are correct. Since Rocket.blastOff() is private, it can't be overridden, and it is invisible to class Shuttle. 1, 3, 4, and 5 are incorrect based on the above."
      },
      {
        "question_id": 3,
        "correct_answers": [2],
        "explanation": "2 is correct. This question is using valid (but inappropriate and weird) identifiers, static imports, main(), and pre-incrementing logic. 1, 3, 4, 5, 6, and 7 are incorrect based on the above."
      },
      {
        "question_id": 4,
        "correct_answers": [1],
        "explanation": "1 is correct; enums can have constructors and variables. 2, 3, 4, 5, and 6 are incorrect; these lines all use correct syntax."
      },
      {
        "question_id": 5,
        "correct_answers": [4, 5],
        "explanation": "4 and 5 are correct. Variable a has default access, so it cannot be accessed from outside the package. Variable b has protected access in pkgA. 1, 2, 3, and 6 are incorrect based on the above information."
      },
      {
        "question_id": 6,
        "correct_answers": [1],
        "explanation": "1 is correct; all of these are legal declarations. 2, 3, 4, 5, and 6 are incorrect based on the above information. "
      },
      {
        "question_id": 7,
        "correct_answers": [3, 4],
        "explanation": "3, 4 are correct. Variable names cannot begin with #, and an array declaration can't include a size without an instantiation. The rest of the code is valid. 1, 2, and 5 are incorrect based on the above."
      },
      {
        "question_id": 8,
        "correct_answers": [2],
        "explanation": "2 is correct. Every enum comes with a static values() method that returns an array of the enum's values, in the order in which they are declared in the enum. 1, 3, 4, 5, 6, and 7 are incorrect based on the above information. "
      },
      {
        "question_id": 9,
        "correct_answers": [4],
        "explanation": "4 is correct. The countGold() method cannot be invoked from a static context. 1, 2, 3, and 5 are incorrect based on the above information."
      },
      {
        "question_id": 10,
        "correct_answers": [1],
        "explanation": "1 is correct. By default, an interface's methods are public so the Tablet.doStuff method must be public, too. The rest of the code is valid. 2, 3, 4, and 5 are incorrect based on the above."
      },
      {
        "question_id": 11,
        "correct_answers": [3, 5],
        "explanation": "3 and 5 are correct syntax for static imports. Line 4 isn't making use of static imports, so the code will also compile with none of the imports. 1, 2, 4, and 6 are incorrect based on the above. "
      }
    ]
  },
  {
    "theme_id": 2,
    "theme_content": "Declarations and Access Control",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [2, 5],
        "explanation": "2 and 5 are correct. 2 is correct because an abstract class need not implement any or all of an interface's methods. 5 is correct because the class implements the interface method and additionally overloads the twiddle() method. 1, 3, and 4 are incorrect. 1 is incorrect because abstract methods have no body. 3 is incorrect because classes implement interfaces; they don't extend them. 4 is incorrect because overloading a method is not implementing it. "
      },
      {
        "question_id": 2,
        "correct_answers": [5],
        "explanation": "5 is correct. The implied super() call in Bottom2's constructor cannot be satisfied because there is no no-arg constructor in Top. A default, no-arg constructor is generated by the compiler only if the class has no constructor defined explicitly. 1, 2, 3, and 4 are incorrect based on the above."
      },
      {
        "question_id": 3,
        "correct_answers": [1],
        "explanation": "1 is correct. Although a final method cannot be overridden, in this case, the method is private, and therefore hidden. The effect is that a new, accessible, method flipper is created. Therefore, no polymorphism occurs in this example, the method invoked is simply that of the child class, and no error occurs. 2, 3, 4, and 5 are incorrect based on the preceding. "
      },
      {
        "question_id": 4,
        "correct_answers": [4],
        "explanation": "4 is correct. Static init blocks are executed at class loading time; instance init blocks run right after the call to super() in a constructor. When multiple init blocks of a single type occur in a class, they run in order, from the top down. 1, 2, 3, 5, 6, 7, 8, and 9 are incorrect based on the above. Note: You'll probably never see this many choices on the real exam! "
      },
      {
        "question_id": 5,
        "correct_answers": [3],
        "explanation": "3 is correct. Before you can invoke Y's do2 method, you have to cast x2 to be of type Y. 1, 2, and 4 are incorrect based on the preceding. B looks like a proper cast, but without the second set of parentheses, the compiler thinks it's an incomplete statement."
      },
      {
        "question_id": 6,
        "correct_answers": [1],
        "explanation": "1 is correct. It's legal to overload main(). Since no instances of Locomotive are created, the constructor does not run and the overloaded version of main() does not run. 2, 3, 4, and 5 are incorrect based on the preceding. "
      },
      {
        "question_id": 7,
        "correct_answers": [6],
        "explanation": "6 is correct. Class Dog doesn't have a sniff method. 1, 2, 3, 4, and 5 are incorrect based on the above information."
      },
      {
        "question_id": 8,
        "correct_answers": [1],
        "explanation": "1 is correct. A ClassCastException will be thrown when the code attempts to downcast a Tree to a Redwood. 2, 3, 4, 5, and 6 are incorrect based on the above information."
      },
      {
        "question_id": 9,
        "correct_answers": [2],
        "explanation": "2 is correct. The code is correct, but polymorphism doesn't apply to static methods. 1, 3, 4, and 5 are incorrect based on the above information."
      },
      {
        "question_id": 10,
        "correct_answers": [3],
        "explanation": "3 is correct. Watch out, because SubSubAlpha extends Alpha! Since the code doesn't attempt to make a SubAlpha, the private constructor in SubAlpha is okay. 1, 2, 4, 5, and 6 are incorrect based on the above information."
      },
      {
        "question_id": 11,
        "correct_answers": [3],
        "explanation": "3 is correct. Remember that constructors call their superclass constructors, which execute first, and that constructors can be overloaded. 1, 2, 4, 5, 6, 7, and 8 are incorrect based on the above information."
      },
      {
        "question_id": 12,
        "correct_answers": [1],
        "explanation": "1 is correct. Polymorphism is only for instance methods, not instance variables. 2, 3, 4, 5, and 6 are incorrect based on the above information."
      },
      {
        "question_id": 13,
        "correct_answers": [1, 3],
        "explanation": "1 and 3 are correct. The phrase \"type of\" indicates an IS-A relationship (extends or implements), and the word \"have\" of course indicates a HAS-A relationship (usually instance variables). 2 and 4 are incorrect based on the above information. "
      }
    ]
  },
  {
    "theme_id": 3,
    "theme_content": "Assignments",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [3],
        "explanation": "3 is correct. Only one CardBoard object (c1) is eligible, but it has an associated Short wrapper object that is also eligible.1, 2, 4, 5, and 6 are incorrect based on the above."
      },
      {
        "question_id": 2,
        "correct_answers": [5],
        "explanation": "5 is correct; compilation of line E fails. When a mathematical operation is performed on any primitives smaller than ints, the result is automatically cast to an integer.1, 2, 3, and 4 are all legal primitive casts. "
      },
      {
        "question_id": 3,
        "correct_answers": [3],
        "explanation": "3 is correct; line C will NOT compile. As of Java 7, underscores can be included in numeric literals, but not at the beginning or the end. 1, 2, 4, 5, and 6 are incorrect. A and B are legal numeric literals. D and E are examples of valid binary literals, which are also new to Java 7, and F is a valid hexadecimal literal that uses an underscore."
      },
      {
        "question_id": 4,
        "correct_answers": [6],
        "explanation": "6 is correct. The m2 object's m1 instance variable is never initialized, so when m5 tries to use it a NullPointerException is thrown. 1, 2, 3, 4, and 5 are incorrect based on the above. "
      },
      {
        "question_id": 5,
        "correct_answers": [1],
        "explanation": "1 is correct. The references f1, z, and f3 all refer to the same instance of Fizz. The final modifier assures that a reference variable cannot be referred to a different object, but final doesn't keep the object's state from changing. 2, 3, 4, 5, and 6 are incorrect based on the above. "
      },
      {
        "question_id": 6,
        "correct_answers": [2],
        "explanation": "2 is correct. In the go() method, m refers to the single Mirror instance, but the int i is a new int variable, a detached copy of i2. 1, 3, 4, 5, and 6 are incorrect based on the above."
      },
      {
        "question_id": 7,
        "correct_answers": [1,2,7],
        "explanation": "1, 2, and 7 are correct. The constructor sets the value of id for w1 and w2. When the commented line is reached, none of the three Wind objects can be accessed, so they are eligible to be garbage collected. 3, 4, 5, and 6 are incorrect based on the above."
      },
      {
        "question_id": 8,
        "correct_answers": [5],
        "explanation": "5 is correct. The parameter declared on line 9 is valid (although ugly), but the variable name ouch cannot be declared again on line 11 in the same scope as the declaration on line 9. 1, 2, 3, 4, and 6 are incorrect based on the above."
      },
      {
        "question_id": 9,
        "correct_answers": [4],
        "explanation": "D is correct. Inside the go() method, h1 is out of scope. 1, 2, 3, and 5 are incorrect based on the above."
      },
      {
        "question_id": 10,
        "correct_answers": [1],
        "explanation": "1 is correct. Three Network objects are created. The n2 object has a reference to the n1 object, and the n3 object has a reference to the n2 object. The S.O.P. can be read as, \"Use the n3 object's Network reference (the first p), to find that object's reference (n2), and use that object's reference (the second p) to find that object's (n1's) id, and print that id.\" 2, 3, 4, and 5 are incorrect based on the above. "
      },
      {
        "question_id": 11,
        "correct_answers": [2],
        "explanation": "2 is correct. It should be clear that there is still a reference to the object referred to by a2, and that there is still a reference to the object referred to by a2.b2. What might be less clear is that you can still access the other Beta object through the static variable a2.b1—because it's static. 1, 3, 4, 5, and 6 are incorrect based on the above."
      },
      {
        "question_id": 12,
        "correct_answers": [2],
        "explanation": "2 is correct. In the Telescope class, there are three different variables named magnify. The go() method's version and the zoomMore() method's version are not used in the zoomIn() method. The zoomIn() method multiplies the class variable * 5. The result (10) is sent to zoomMore(), but what happens in zoomMore() stays in zoomMore(). The S.O.P. prints the value of zoomIn()'s magnify. 1, 3, 4, 5, 6, and 7 are incorrect based on the above. "
      },
      {
        "question_id": 13,
        "correct_answers": [5],
        "explanation": "5 is correct. In go1() the local variable x is not initialized. 1, 2, 3, 4, and 6 are incorrect based on the above."
      }
    ]
  },
  {
    "theme_id": 4,
    "theme_content": "Operations",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [4],
        "explanation": "4 is correct. This is a ternary nested in a ternary. Both of the ternary expressions are false. 1, 2, 3, 5, and 6 are incorrect based on the above."
      },
      {
        "question_id": 2,
        "correct_answers": [3],
        "explanation": "3 is correct. The == operator tests for reference variable equality, not object equality. 1, 2, 4, 5, and 6 are incorrect based on the above."
      },

      {
        "question_id": 3,
        "correct_answers": [5],
        "explanation": "5 is correct. Because the short circuit (||) is not used, both operands are evaluated. Since args[1] is past the args array bounds, an ArrayIndexOutOfBoundsException is thrown. 1, 2, 3, and 4 are incorrect based on the above."
      },
      {
        "question_id": 4,
        "correct_answers": [7],
        "explanation": "7 is correct. Concatenation runs from left to right, and if either operand is a String, the operands are concatenated. If both operands are numbers, they are added together. 1, 2, 3, 4, 5, 6, 8, and 9 are incorrect based on the above."
      },
      {
        "question_id": 5,
        "correct_answers": [1],
        "explanation": "1 is correct. When dividing ints, remainders are always rounded down. 2, 3, 4, and 5 are incorrect based on the above."
      },
      {
        "question_id": 6,
        "correct_answers": [1],
        "explanation": "1 is correct. All of this syntax is correct. The for-each iterates through the enum using the values() method to return an array. An enum can be compared using either equals() or ==. An enum can be used in a ternary operator's boolean test. 2, 3, 4, 5, 6, and 7 are incorrect based on the above."
      },
      {
        "question_id": 7,
        "correct_answers": [3],
        "explanation": "3 is correct. Line 9 uses the modulus operator, which returns the remainder of the divi- sion, which in this case is 1. Also, line 9 sets b2 to false, and it doesn't test b2's value. Line 10 sets b2 to true, and it doesn’t test its value; however, the short-circuit operator keeps the expression b2 = true from being executed. 1, 2, 4, and 5 are incorrect based on the above. "
      },
      {
        "question_id": 8,
        "correct_answers": [3, 6],
        "explanation": "3 and 6 are correct. At line 7 the || keeps count from being incremented, but the | allows mask to be incremented. At line 8 the ^ returns true only if exactly one operand is true. At line 9 mask is 2 and the && keeps count from being incremented. 1, 2, 4, 5, and 7 are incorrect based on the above. "
      },
      {
        "question_id": 9,
        "correct_answers": [4],
        "explanation": "4 is correct. First, remember that instanceof can look up through multiple levels of an inheritance tree. Also remember that instanceof is commonly used before attempt- ing a downcast, so in this case, after line 15, it would be possible to say Speedboat s3 = (Speedboat)b2;. 1, 2, 3, 5, and 6 are incorrect based on the above. "
      }
    ]
  }
]