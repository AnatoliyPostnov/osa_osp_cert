[
  {
    "theme_id": 1,
    "theme_content": "Declarations and Access Control",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [3],
        "explanation": "1 is incorrect because classes implement interfaces, they don't extend them. 2 is incorrect because interfaces only \"inherit from\" other interfaces. 4 is incorrect based on the preceding rules."
      },
      {
        "question_id": 2,
        "correct_answers": [2, 6],
        "explanation": "2 and 6 are correct. Since Rocket.blastOff() is private, it can't be overridden, and it is invisible to class Shuttle. 1, 3, 4, and 5 are incorrect based on the above."
      },
      {
        "question_id": 3,
        "correct_answers": [2],
        "explanation": "2 is correct. This question is using valid (but inappropriate and weird) identifiers, static imports, main(), and pre-incrementing logic. 1, 3, 4, 5, 6, and 7 are incorrect based on the above."
      },
      {
        "question_id": 4,
        "correct_answers": [1],
        "explanation": "1 is correct; enums can have constructors and variables. 2, 3, 4, 5, and 6 are incorrect; these lines all use correct syntax."
      },
      {
        "question_id": 5,
        "correct_answers": [4, 5],
        "explanation": "4 and 5 are correct. Variable a has default access, so it cannot be accessed from outside the package. Variable b has protected access in pkgA. 1, 2, 3, and 6 are incorrect based on the above information."
      },
      {
        "question_id": 6,
        "correct_answers": [1],
        "explanation": "1 is correct; all of these are legal declarations. 2, 3, 4, 5, and 6 are incorrect based on the above information. "
      },
      {
        "question_id": 7,
        "correct_answers": [3, 4],
        "explanation": "3, 4 are correct. Variable names cannot begin with #, and an array declaration can't include a size without an instantiation. The rest of the code is valid. 1, 2, and 5 are incorrect based on the above."
      },
      {
        "question_id": 8,
        "correct_answers": [2],
        "explanation": "2 is correct. Every enum comes with a static values() method that returns an array of the enum's values, in the order in which they are declared in the enum. 1, 3, 4, 5, 6, and 7 are incorrect based on the above information. "
      },
      {
        "question_id": 9,
        "correct_answers": [4],
        "explanation": "4 is correct. The countGold() method cannot be invoked from a static context. 1, 2, 3, and 5 are incorrect based on the above information."
      },
      {
        "question_id": 10,
        "correct_answers": [1],
        "explanation": "1 is correct. By default, an interface's methods are public so the Tablet.doStuff method must be public, too. The rest of the code is valid. 2, 3, 4, and 5 are incorrect based on the above."
      },
      {
        "question_id": 11,
        "correct_answers": [3, 5],
        "explanation": "3 and 5 are correct syntax for static imports. Line 4 isn't making use of static imports, so the code will also compile with none of the imports. 1, 2, 4, and 6 are incorrect based on the above. "
      }
    ]
  },
  {
    "theme_id": 2,
    "theme_content": "Declarations and Access Control",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [2, 5],
        "explanation": "2 and 5 are correct. 2 is correct because an abstract class need not implement any or all of an interface's methods. 5 is correct because the class implements the interface method and additionally overloads the twiddle() method. 1, 3, and 4 are incorrect. 1 is incorrect because abstract methods have no body. 3 is incorrect because classes implement interfaces; they don't extend them. 4 is incorrect because overloading a method is not implementing it. "
      },
      {
        "question_id": 2,
        "correct_answers": [5],
        "explanation": "5 is correct. The implied super() call in Bottom2's constructor cannot be satisfied because there is no no-arg constructor in Top. A default, no-arg constructor is generated by the compiler only if the class has no constructor defined explicitly. 1, 2, 3, and 4 are incorrect based on the above."
      },
      {
        "question_id": 3,
        "correct_answers": [1],
        "explanation": "1 is correct. Although a final method cannot be overridden, in this case, the method is private, and therefore hidden. The effect is that a new, accessible, method flipper is created. Therefore, no polymorphism occurs in this example, the method invoked is simply that of the child class, and no error occurs. 2, 3, 4, and 5 are incorrect based on the preceding. "
      },
      {
        "question_id": 4,
        "correct_answers": [4],
        "explanation": "4 is correct. Static init blocks are executed at class loading time; instance init blocks run right after the call to super() in a constructor. When multiple init blocks of a single type occur in a class, they run in order, from the top down. 1, 2, 3, 5, 6, 7, 8, and 9 are incorrect based on the above. Note: You'll probably never see this many choices on the real exam! "
      },
      {
        "question_id": 5,
        "correct_answers": [3],
        "explanation": "3 is correct. Before you can invoke Y's do2 method, you have to cast x2 to be of type Y. 1, 2, and 4 are incorrect based on the preceding. B looks like a proper cast, but without the second set of parentheses, the compiler thinks it's an incomplete statement."
      },
      {
        "question_id": 6,
        "correct_answers": [1],
        "explanation": "1 is correct. It's legal to overload main(). Since no instances of Locomotive are created, the constructor does not run and the overloaded version of main() does not run. 2, 3, 4, and 5 are incorrect based on the preceding. "
      },
      {
        "question_id": 7,
        "correct_answers": [6],
        "explanation": "6 is correct. Class Dog doesn't have a sniff method. 1, 2, 3, 4, and 5 are incorrect based on the above information."
      },
      {
        "question_id": 8,
        "correct_answers": [1],
        "explanation": "1 is correct. A ClassCastException will be thrown when the code attempts to downcast a Tree to a Redwood. 2, 3, 4, 5, and 6 are incorrect based on the above information."
      },
      {
        "question_id": 9,
        "correct_answers": [2],
        "explanation": "2 is correct. The code is correct, but polymorphism doesn't apply to static methods. 1, 3, 4, and 5 are incorrect based on the above information."
      },
      {
        "question_id": 10,
        "correct_answers": [3],
        "explanation": "3 is correct. Watch out, because SubSubAlpha extends Alpha! Since the code doesn't attempt to make a SubAlpha, the private constructor in SubAlpha is okay. 1, 2, 4, 5, and 6 are incorrect based on the above information."
      },
      {
        "question_id": 11,
        "correct_answers": [3],
        "explanation": "3 is correct. Remember that constructors call their superclass constructors, which execute first, and that constructors can be overloaded. 1, 2, 4, 5, 6, 7, and 8 are incorrect based on the above information."
      },
      {
        "question_id": 12,
        "correct_answers": [1],
        "explanation": "1 is correct. Polymorphism is only for instance methods, not instance variables. 2, 3, 4, 5, and 6 are incorrect based on the above information."
      },
      {
        "question_id": 13,
        "correct_answers": [1, 3],
        "explanation": "1 and 3 are correct. The phrase \"type of\" indicates an IS-A relationship (extends or implements), and the word \"have\" of course indicates a HAS-A relationship (usually instance variables). 2 and 4 are incorrect based on the above information. "
      }
    ]
  },
  {
    "theme_id": 3,
    "theme_content": "Assignments",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [3],
        "explanation": "3 is correct. Only one CardBoard object (c1) is eligible, but it has an associated Short wrapper object that is also eligible.1, 2, 4, 5, and 6 are incorrect based on the above."
      },
      {
        "question_id": 2,
        "correct_answers": [5],
        "explanation": "5 is correct; compilation of line E fails. When a mathematical operation is performed on any primitives smaller than ints, the result is automatically cast to an integer.1, 2, 3, and 4 are all legal primitive casts. "
      },
      {
        "question_id": 3,
        "correct_answers": [3],
        "explanation": "3 is correct; line C will NOT compile. As of Java 7, underscores can be included in numeric literals, but not at the beginning or the end. 1, 2, 4, 5, and 6 are incorrect. A and B are legal numeric literals. D and E are examples of valid binary literals, which are also new to Java 7, and F is a valid hexadecimal literal that uses an underscore."
      },
      {
        "question_id": 4,
        "correct_answers": [6],
        "explanation": "6 is correct. The m2 object's m1 instance variable is never initialized, so when m5 tries to use it a NullPointerException is thrown. 1, 2, 3, 4, and 5 are incorrect based on the above. "
      },
      {
        "question_id": 5,
        "correct_answers": [1],
        "explanation": "1 is correct. The references f1, z, and f3 all refer to the same instance of Fizz. The final modifier assures that a reference variable cannot be referred to a different object, but final doesn't keep the object's state from changing. 2, 3, 4, 5, and 6 are incorrect based on the above. "
      },
      {
        "question_id": 6,
        "correct_answers": [2],
        "explanation": "2 is correct. In the go() method, m refers to the single Mirror instance, but the int i is a new int variable, a detached copy of i2. 1, 3, 4, 5, and 6 are incorrect based on the above."
      },
      {
        "question_id": 7,
        "correct_answers": [1,2,7],
        "explanation": "1, 2, and 7 are correct. The constructor sets the value of id for w1 and w2. When the commented line is reached, none of the three Wind objects can be accessed, so they are eligible to be garbage collected. 3, 4, 5, and 6 are incorrect based on the above."
      },
      {
        "question_id": 8,
        "correct_answers": [5],
        "explanation": "5 is correct. The parameter declared on line 9 is valid (although ugly), but the variable name ouch cannot be declared again on line 11 in the same scope as the declaration on line 9. 1, 2, 3, 4, and 6 are incorrect based on the above."
      },
      {
        "question_id": 9,
        "correct_answers": [4],
        "explanation": "D is correct. Inside the go() method, h1 is out of scope. 1, 2, 3, and 5 are incorrect based on the above."
      },
      {
        "question_id": 10,
        "correct_answers": [1],
        "explanation": "1 is correct. Three Network objects are created. The n2 object has a reference to the n1 object, and the n3 object has a reference to the n2 object. The S.O.P. can be read as, \"Use the n3 object's Network reference (the first p), to find that object's reference (n2), and use that object's reference (the second p) to find that object's (n1's) id, and print that id.\" 2, 3, 4, and 5 are incorrect based on the above. "
      },
      {
        "question_id": 11,
        "correct_answers": [2],
        "explanation": "2 is correct. It should be clear that there is still a reference to the object referred to by a2, and that there is still a reference to the object referred to by a2.b2. What might be less clear is that you can still access the other Beta object through the static variable a2.b1—because it's static. 1, 3, 4, 5, and 6 are incorrect based on the above."
      },
      {
        "question_id": 12,
        "correct_answers": [2],
        "explanation": "2 is correct. In the Telescope class, there are three different variables named magnify. The go() method's version and the zoomMore() method's version are not used in the zoomIn() method. The zoomIn() method multiplies the class variable * 5. The result (10) is sent to zoomMore(), but what happens in zoomMore() stays in zoomMore(). The S.O.P. prints the value of zoomIn()'s magnify. 1, 3, 4, 5, 6, and 7 are incorrect based on the above. "
      },
      {
        "question_id": 13,
        "correct_answers": [5],
        "explanation": "5 is correct. In go1() the local variable x is not initialized. 1, 2, 3, 4, and 6 are incorrect based on the above."
      }
    ]
  },
  {
    "theme_id": 4,
    "theme_content": "Operations",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [4],
        "explanation": "4 is correct. This is a ternary nested in a ternary. Both of the ternary expressions are false. 1, 2, 3, 5, and 6 are incorrect based on the above."
      },
      {
        "question_id": 2,
        "correct_answers": [3],
        "explanation": "3 is correct. The == operator tests for reference variable equality, not object equality. 1, 2, 4, 5, and 6 are incorrect based on the above."
      },

      {
        "question_id": 3,
        "correct_answers": [5],
        "explanation": "5 is correct. Because the short circuit (||) is not used, both operands are evaluated. Since args[1] is past the args array bounds, an ArrayIndexOutOfBoundsException is thrown. 1, 2, 3, and 4 are incorrect based on the above."
      },
      {
        "question_id": 4,
        "correct_answers": [7],
        "explanation": "7 is correct. Concatenation runs from left to right, and if either operand is a String, the operands are concatenated. If both operands are numbers, they are added together. 1, 2, 3, 4, 5, 6, 8, and 9 are incorrect based on the above."
      },
      {
        "question_id": 5,
        "correct_answers": [1],
        "explanation": "1 is correct. When dividing ints, remainders are always rounded down. 2, 3, 4, and 5 are incorrect based on the above."
      },
      {
        "question_id": 6,
        "correct_answers": [1],
        "explanation": "1 is correct. All of this syntax is correct. The for-each iterates through the enum using the values() method to return an array. An enum can be compared using either equals() or ==. An enum can be used in a ternary operator's boolean test. 2, 3, 4, 5, 6, and 7 are incorrect based on the above."
      },
      {
        "question_id": 7,
        "correct_answers": [3],
        "explanation": "3 is correct. Line 9 uses the modulus operator, which returns the remainder of the divi- sion, which in this case is 1. Also, line 9 sets b2 to false, and it doesn't test b2's value. Line 10 sets b2 to true, and it doesn’t test its value; however, the short-circuit operator keeps the expression b2 = true from being executed. 1, 2, 4, and 5 are incorrect based on the above. "
      },
      {
        "question_id": 8,
        "correct_answers": [3, 6],
        "explanation": "3 and 6 are correct. At line 7 the || keeps count from being incremented, but the | allows mask to be incremented. At line 8 the ^ returns true only if exactly one operand is true. At line 9 mask is 2 and the && keeps count from being incremented. 1, 2, 4, 5, and 7 are incorrect based on the above. "
      },
      {
        "question_id": 9,
        "correct_answers": [4],
        "explanation": "4 is correct. First, remember that instanceof can look up through multiple levels of an inheritance tree. Also remember that instanceof is commonly used before attempt- ing a downcast, so in this case, after line 15, it would be possible to say Speedboat s3 = (Speedboat)b2;. 1, 2, 3, 5, and 6 are incorrect based on the above. "
      }
    ]
  },
  {
    "theme_id": 5,
    "theme_content": "Working with string, Arrays and ArrayLists",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [1, 4],
        "explanation": "1 and 4 are correct. The String operations are working on a new (lost) String not String s. The StringBuilder operations work from left to right. 2, 3, and 5 are incorrect based on the above. "
      },
      {
        "question_id": 2,
        "correct_answers": [4],
        "explanation": "4 is correct. The horses array's first four elements contain Strings, but the fifth is null, so the toUpperCase() invocation for the fifth element throws a NullPointerException. 1, 2, 3, 5, and 6 are incorrect based on the above. "
      },
      {
        "question_id": 3,
        "correct_answers": [5],
        "explanation": "5 is correct. The Unicode declaration must be enclosed in single quotes: '\\u004e'. If this were done, the answer would be A, but knowing that equality isn't on the OCA exam. 1, 2, 3, and 4 are incorrect based on the above."
      },
      {
        "question_id": 4,
        "correct_answers": [3],
        "explanation": "3 is correct. A ClassCastException is thrown at line 7 because o1 refers to an int[][], not an int[]. If line 7 were removed, the output would be 4. 1, 2, 4, 5, 6, and 7 are incorrect based on the above."
      },
      {
        "question_id": 5,
        "correct_answers": [2],
        "explanation": "2 is correct. ArrayList elements are automatically inserted in the order of entry; they are not automatically sorted. ArrayLists use zero-based indexes and the last add() inserts a new element and shifts the remaining elements back. 1, 3, 4, 5, 6, and 7 are incorrect based on the above."
      },
      {
        "question_id": 6,
        "correct_answers": [3, 6],
        "explanation": "3 and 6 are correct. da refers to an object of type \"Dozens array\" and each Dozens object that is created comes with its own \"int array\" object. When line 14 is reached, only the second Dozens object (and its \"int array\" object) are not reachable. 1, 2, 4, 5, and 7 are incorrect based on the above. "
      },
      {
        "question_id": 7,
        "correct_answers": [3],
        "explanation": "3 is correct. A two-dimensional array is an \"array of arrays.\" The length of ba is 2 because it contains two, one-dimensional arrays. Array indexes are zero-based, so ba[1] refers to ba's second array. 1, 2, 4, 5, 6, and 7 are incorrect based on the above. "
      },
      {
        "question_id": 8,
        "correct_answers": [4, 6],
        "explanation": "4 and 6 are correct. Although String objects are immutable, references to Strings are mutable. The code s1 += \"d\"; creates a new String object. StringBuilder objects are mutable, so the append() is changing the single StringBuilder object to which both StringBuilder references refer. 1, 2, 3, 5, and 7 are incorrect based on the above."
      },
      {
        "question_id": 9,
        "correct_answers": [2],
        "explanation": "2 is correct. StringBuilders are mutable, so all of the append() invocations are acting upon the same StringBuilder object over and over. Strings, however, are immutable, so every String concatenation operation results in a new String object. Also, the string \" \" is created once and reused in every loop iteration. 1, 3, 4, and 5 are incorrect based on the above. "
      },
      {
        "question_id": 10,
        "correct_answers": [1],
        "explanation": "1 is correct. Although main()'s b1 is a different reference variable than go()'s b1, they refer to the same Box object. 2, 3, 4, 5, and 6 are incorrect based on the above. "
      },
      {
        "question_id": 11,
        "correct_answers": [4],
        "explanation": "4 is correct. The substring() invocation uses a zero-based index and the second argument is exclusive, so the character at index 8 is NOT included. The toUpperCase() invocation makes a new String object that is instantly lost. The toUpperCase() invocation does NOT affect the String referred to by s. 1, 2, 3, 5, 6, and 7 are incorrect based on the above."
      },
      {
        "question_id": 12,
        "correct_answers": [6],
        "explanation": "6 is correct. When encapsulating a mutable object like an ArrayList, your getter must return a reference to a copy of the object, not just the reference to the original object. 1, 2, 3, 4, 5, and 7 are incorrect based on the above."
      }
    ]
  },
  {
    "theme_id": 6,
    "theme_content": "Flow Control and Exceptions",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [1],
        "explanation": "1 is correct. As of Java 7 the code is legal, but the substring() method's second argument is exclusive. If the invocation had been substring(1,4), the output would have been –rg. Note: We hope you won't have too many exam questions that focus on API trivia like this one. If you knew the switch was legal, give yourself \"almost full credit.\" 2, 3, 4, and 5 are incorrect based on the above."
      },
      {
        "question_id": 2,
        "correct_answers": [2],
        "explanation": "2 is correct. Once s3() throws the exception to s2(), s2() throws it to s1(), and no more of s2()'s code will be executed. 1, 3, 4, 5, 6, 7, and 8 are incorrect based on the above."
      },
      {
        "question_id": 3,
        "correct_answers": [3, 4],
        "explanation": "3 and 4 are correct. Integer.parseInt can throw a NumberFormatException, and IllegalArgumentException is its superclass (that is, a broader exception). 1, 2, 5, and 6 are not in NumberFormatException's class hierarchy."
      },
      {
        "question_id": 4,
        "correct_answers": [5],
        "explanation": "5 is correct. As of Java 7 the syntax is legal. The sa[] array receives only three arguments from the command line, so on the last iteration through sa[], a NullPointerException is thrown. 1, 2, 3, and 4 are incorrect based on the above."
      },
      {
        "question_id": 5,
        "correct_answers": [1, 4, 6],
        "explanation": "1, 4, and 6 are correct. 1 is an example of the enhanced for loop. 4 and 6 are examples of the basic for loop. 2, 3, and 5 are incorrect. 2 is incorrect because its operands are swapped. 3 is incorrect because the enhanced for must declare its first operand. 5 is incorrect syntax to declare two variables in a for statement."
      },
      {
        "question_id": 6,
        "correct_answers": [5],
        "explanation": "5 is correct. There is no problem nesting try/catch blocks. As is normal, when an exception is thrown, the code in the catch block runs, and then the code in the finally block runs. 1, 2, 3, 4, and 6 are incorrect based on the above. "
      },
      {
        "question_id": 7,
        "correct_answers": [3],
        "explanation": "3 is correct. An overriding method cannot throw a broader exception than the method it's overriding. Class CC4's method is an overload, not an override. 1, 2, 4, and 5 are incorrect based on the above."
      },
      {
        "question_id": 8,
        "correct_answers": [4],
        "explanation": "4 is correct. Did you catch the static initializer block? Remember that switches work on \"fall-through\" logic, and that fall-through logic also applies to the default case, which is used when no other case matches. 1, 2, 3, 5, 6, and 7 are incorrect based on the above."
      },
      {
        "question_id": 9,
        "correct_answers": [4, 5],
        "explanation": "4 and 5 are correct. Because i was not initialized, case 1 will throw a NullPointerException. Case 0 will initiate an endless loop, not a stack overflow. Case 2's downcast will not cause an exception. 1, 2, 3, 5, and 7 are incorrect based on the above."
      },
      {
        "question_id": 10,
        "correct_answers": [4],
        "explanation": "4 is correct. The basic rule for unlabeled continue statements is that the current iteration stops early and execution jumps to the next iteration. The last two continue statements are redundant! 1, 2, 3, 5, and 6 are incorrect based on the above."
      },
      {
        "question_id": 11,
        "correct_answers": [8],
        "explanation": "8 is correct. It's true that the value of String s is 123 at the time that the divide-by-zero exception is thrown, but finally() is not guaranteed to complete, and in this case finally() never completes, so the System.out.println (S.O.P) never executes. 1, 2, 3, 4, 5, 6, and 7 are incorrect based on the above. "
      },
      {
        "question_id": 12,
        "correct_answers": [3],
        "explanation": "3 is correct. A break breaks out of the current innermost loop and carries on. A labeled break breaks out of and terminates the labeled loops. 1, 2, 4, 5, and 6 are incorrect based on the above. "
      },
      {
        "question_id": 13,
        "correct_answers": [2, 5],
        "explanation": "2 and 5 are correct. First off, go() is a badly designed recursive method, guaranteed to cause a StackOverflowError. Since Exception is not a superclass of Error, catching an Exception will not help handle an Error, so fragment III will not complete normally. Only fragment II will catch the Error. 1, 3, 4, and 6 are incorrect based on the above. "
      },
      {
        "question_id": 14,
        "correct_answers": [5],
        "explanation": "5 is correct. A switch's cases must be compile-time constants or enum values. 1, 2, 3, 4, 6, and 7 are incorrect based on the above. "
      },
      {
        "question_id": 15,
        "correct_answers": [4],
        "explanation": "4 is correct. This is kind of sneaky, but remember that we're trying to toughen you up for the real exam. If you're going to throw an IOException, you have to import the java.io package or declare the exception with a fully qualified name. 1, 2, 3, and 5 are incorrect. 1, 2, and 3 are incorrect based on the above. 5 is incorrect because it's okay both to handle and declare an exception. "
      },
      {
        "question_id": 16,
        "correct_answers": [3, 4],
        "explanation": "3 and 4 are correct. An overriding method cannot throw checked exceptions that are broader than those thrown by the overridden method. However, an overriding method can throw RuntimeExceptions not thrown by the overridden method. 1, 2, 5, and 6 are incorrect based on the above. "
      }
    ]
  }
]
