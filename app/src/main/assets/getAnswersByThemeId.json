[
  {
    "exam_id": 1,
    "theme_id": 1,
    "theme_content": "Declarations and Access Control",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [3],
        "explanation": "1 is incorrect because classes implement interfaces, they don't extend them. 2 is incorrect because interfaces only \"inherit from\" other interfaces. 4 is incorrect based on the preceding rules."
      },
      {
        "question_id": 2,
        "correct_answers": [2, 6],
        "explanation": "2 and 6 are correct. Since Rocket.blastOff() is private, it can't be overridden, and it is invisible to class Shuttle. 1, 3, 4, and 5 are incorrect based on the above."
      },
      {
        "question_id": 3,
        "correct_answers": [2],
        "explanation": "2 is correct. This question is using valid (but inappropriate and weird) identifiers, static imports, main(), and pre-incrementing logic. 1, 3, 4, 5, 6, and 7 are incorrect based on the above."
      },
      {
        "question_id": 4,
        "correct_answers": [1],
        "explanation": "1 is correct; enums can have constructors and variables. 2, 3, 4, 5, and 6 are incorrect; these lines all use correct syntax."
      },
      {
        "question_id": 5,
        "correct_answers": [4, 5],
        "explanation": "4 and 5 are correct. Variable a has default access, so it cannot be accessed from outside the package. Variable b has protected access in pkgA. 1, 2, 3, and 6 are incorrect based on the above information."
      },
      {
        "question_id": 6,
        "correct_answers": [1],
        "explanation": "1 is correct; all of these are legal declarations. 2, 3, 4, 5, and 6 are incorrect based on the above information. "
      },
      {
        "question_id": 7,
        "correct_answers": [3, 4],
        "explanation": "3, 4 are correct. Variable names cannot begin with #, and an array declaration can't include a size without an instantiation. The rest of the code is valid. 1, 2, and 5 are incorrect based on the above."
      },
      {
        "question_id": 8,
        "correct_answers": [2],
        "explanation": "2 is correct. Every enum comes with a static values() method that returns an array of the enum's values, in the order in which they are declared in the enum. 1, 3, 4, 5, 6, and 7 are incorrect based on the above information. "
      },
      {
        "question_id": 9,
        "correct_answers": [4],
        "explanation": "4 is correct. The countGold() method cannot be invoked from a static context. 1, 2, 3, and 5 are incorrect based on the above information."
      },
      {
        "question_id": 10,
        "correct_answers": [1],
        "explanation": "1 is correct. By default, an interface's methods are public so the Tablet.doStuff method must be public, too. The rest of the code is valid. 2, 3, 4, and 5 are incorrect based on the above."
      },
      {
        "question_id": 11,
        "correct_answers": [3, 5],
        "explanation": "3 and 5 are correct syntax for static imports. Line 4 isn't making use of static imports, so the code will also compile with none of the imports. 1, 2, 4, and 6 are incorrect based on the above. "
      }
    ]
  },
  {
    "exam_id": 1,
    "theme_id": 2,
    "theme_content": "Declarations and Access Control",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [2, 5],
        "explanation": "2 and 5 are correct. 2 is correct because an abstract class need not implement any or all of an interface's methods. 5 is correct because the class implements the interface method and additionally overloads the twiddle() method. 1, 3, and 4 are incorrect. 1 is incorrect because abstract methods have no body. 3 is incorrect because classes implement interfaces; they don't extend them. 4 is incorrect because overloading a method is not implementing it. "
      },
      {
        "question_id": 2,
        "correct_answers": [5],
        "explanation": "5 is correct. The implied super() call in Bottom2's constructor cannot be satisfied because there is no no-arg constructor in Top. A default, no-arg constructor is generated by the compiler only if the class has no constructor defined explicitly. 1, 2, 3, and 4 are incorrect based on the above."
      },
      {
        "question_id": 3,
        "correct_answers": [1],
        "explanation": "1 is correct. Although a final method cannot be overridden, in this case, the method is private, and therefore hidden. The effect is that a new, accessible, method flipper is created. Therefore, no polymorphism occurs in this example, the method invoked is simply that of the child class, and no error occurs. 2, 3, 4, and 5 are incorrect based on the preceding. "
      },
      {
        "question_id": 4,
        "correct_answers": [4],
        "explanation": "4 is correct. Static init blocks are executed at class loading time; instance init blocks run right after the call to super() in a constructor. When multiple init blocks of a single type occur in a class, they run in order, from the top down. 1, 2, 3, 5, 6, 7, 8, and 9 are incorrect based on the above. Note: You'll probably never see this many choices on the real exam! "
      },
      {
        "question_id": 5,
        "correct_answers": [3],
        "explanation": "3 is correct. Before you can invoke Y's do2 method, you have to cast x2 to be of type Y. 1, 2, and 4 are incorrect based on the preceding. B looks like a proper cast, but without the second set of parentheses, the compiler thinks it's an incomplete statement."
      },
      {
        "question_id": 6,
        "correct_answers": [1],
        "explanation": "1 is correct. It's legal to overload main(). Since no instances of Locomotive are created, the constructor does not run and the overloaded version of main() does not run. 2, 3, 4, and 5 are incorrect based on the preceding. "
      },
      {
        "question_id": 7,
        "correct_answers": [6],
        "explanation": "6 is correct. Class Dog doesn't have a sniff method. 1, 2, 3, 4, and 5 are incorrect based on the above information."
      },
      {
        "question_id": 8,
        "correct_answers": [1],
        "explanation": "1 is correct. A ClassCastException will be thrown when the code attempts to downcast a Tree to a Redwood. 2, 3, 4, 5, and 6 are incorrect based on the above information."
      },
      {
        "question_id": 9,
        "correct_answers": [2],
        "explanation": "2 is correct. The code is correct, but polymorphism doesn't apply to static methods. 1, 3, 4, and 5 are incorrect based on the above information."
      },
      {
        "question_id": 10,
        "correct_answers": [3],
        "explanation": "3 is correct. Watch out, because SubSubAlpha extends Alpha! Since the code doesn't attempt to make a SubAlpha, the private constructor in SubAlpha is okay. 1, 2, 4, 5, and 6 are incorrect based on the above information."
      },
      {
        "question_id": 11,
        "correct_answers": [3],
        "explanation": "3 is correct. Remember that constructors call their superclass constructors, which execute first, and that constructors can be overloaded. 1, 2, 4, 5, 6, 7, and 8 are incorrect based on the above information."
      },
      {
        "question_id": 12,
        "correct_answers": [1],
        "explanation": "1 is correct. Polymorphism is only for instance methods, not instance variables. 2, 3, 4, 5, and 6 are incorrect based on the above information."
      },
      {
        "question_id": 13,
        "correct_answers": [1, 3],
        "explanation": "1 and 3 are correct. The phrase \"type of\" indicates an IS-A relationship (extends or implements), and the word \"have\" of course indicates a HAS-A relationship (usually instance variables). 2 and 4 are incorrect based on the above information. "
      }
    ]
  },
  {
    "exam_id": 1,
    "theme_id": 3,
    "theme_content": "Assignments",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [3],
        "explanation": "3 is correct. Only one CardBoard object (c1) is eligible, but it has an associated Short wrapper object that is also eligible.1, 2, 4, 5, and 6 are incorrect based on the above."
      },
      {
        "question_id": 2,
        "correct_answers": [5],
        "explanation": "5 is correct; compilation of line E fails. When a mathematical operation is performed on any primitives smaller than ints, the result is automatically cast to an integer.1, 2, 3, and 4 are all legal primitive casts. "
      },
      {
        "question_id": 3,
        "correct_answers": [3],
        "explanation": "3 is correct; line C will NOT compile. As of Java 7, underscores can be included in numeric literals, but not at the beginning or the end. 1, 2, 4, 5, and 6 are incorrect. A and B are legal numeric literals. D and E are examples of valid binary literals, which are also new to Java 7, and F is a valid hexadecimal literal that uses an underscore."
      },
      {
        "question_id": 4,
        "correct_answers": [6],
        "explanation": "6 is correct. The m2 object's m1 instance variable is never initialized, so when m5 tries to use it a NullPointerException is thrown. 1, 2, 3, 4, and 5 are incorrect based on the above. "
      },
      {
        "question_id": 5,
        "correct_answers": [1],
        "explanation": "1 is correct. The references f1, z, and f3 all refer to the same instance of Fizz. The final modifier assures that a reference variable cannot be referred to a different object, but final doesn't keep the object's state from changing. 2, 3, 4, 5, and 6 are incorrect based on the above. "
      },
      {
        "question_id": 6,
        "correct_answers": [2],
        "explanation": "2 is correct. In the go() method, m refers to the single Mirror instance, but the int i is a new int variable, a detached copy of i2. 1, 3, 4, 5, and 6 are incorrect based on the above."
      },
      {
        "question_id": 7,
        "correct_answers": [1,2,7],
        "explanation": "1, 2, and 7 are correct. The constructor sets the value of id for w1 and w2. When the commented line is reached, none of the three Wind objects can be accessed, so they are eligible to be garbage collected. 3, 4, 5, and 6 are incorrect based on the above."
      },
      {
        "question_id": 8,
        "correct_answers": [5],
        "explanation": "5 is correct. The parameter declared on line 9 is valid (although ugly), but the variable name ouch cannot be declared again on line 11 in the same scope as the declaration on line 9. 1, 2, 3, 4, and 6 are incorrect based on the above."
      },
      {
        "question_id": 9,
        "correct_answers": [4],
        "explanation": "D is correct. Inside the go() method, h1 is out of scope. 1, 2, 3, and 5 are incorrect based on the above."
      },
      {
        "question_id": 10,
        "correct_answers": [1],
        "explanation": "1 is correct. Three Network objects are created. The n2 object has a reference to the n1 object, and the n3 object has a reference to the n2 object. The S.O.P. can be read as, \"Use the n3 object's Network reference (the first p), to find that object's reference (n2), and use that object's reference (the second p) to find that object's (n1's) id, and print that id.\" 2, 3, 4, and 5 are incorrect based on the above. "
      },
      {
        "question_id": 11,
        "correct_answers": [2],
        "explanation": "2 is correct. It should be clear that there is still a reference to the object referred to by a2, and that there is still a reference to the object referred to by a2.b2. What might be less clear is that you can still access the other Beta object through the static variable a2.b1—because it's static. 1, 3, 4, 5, and 6 are incorrect based on the above."
      },
      {
        "question_id": 12,
        "correct_answers": [2],
        "explanation": "2 is correct. In the Telescope class, there are three different variables named magnify. The go() method's version and the zoomMore() method's version are not used in the zoomIn() method. The zoomIn() method multiplies the class variable * 5. The result (10) is sent to zoomMore(), but what happens in zoomMore() stays in zoomMore(). The S.O.P. prints the value of zoomIn()'s magnify. 1, 3, 4, 5, 6, and 7 are incorrect based on the above. "
      },
      {
        "question_id": 13,
        "correct_answers": [5],
        "explanation": "5 is correct. In go1() the local variable x is not initialized. 1, 2, 3, 4, and 6 are incorrect based on the above."
      }
    ]
  },
  {
    "exam_id": 1,
    "theme_id": 4,
    "theme_content": "Operations",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [4],
        "explanation": "4 is correct. This is a ternary nested in a ternary. Both of the ternary expressions are false. 1, 2, 3, 5, and 6 are incorrect based on the above."
      },
      {
        "question_id": 2,
        "correct_answers": [3],
        "explanation": "3 is correct. The == operator tests for reference variable equality, not object equality. 1, 2, 4, 5, and 6 are incorrect based on the above."
      },

      {
        "question_id": 3,
        "correct_answers": [5],
        "explanation": "5 is correct. Because the short circuit (||) is not used, both operands are evaluated. Since args[1] is past the args array bounds, an ArrayIndexOutOfBoundsException is thrown. 1, 2, 3, and 4 are incorrect based on the above."
      },
      {
        "question_id": 4,
        "correct_answers": [7],
        "explanation": "7 is correct. Concatenation runs from left to right, and if either operand is a String, the operands are concatenated. If both operands are numbers, they are added together. 1, 2, 3, 4, 5, 6, 8, and 9 are incorrect based on the above."
      },
      {
        "question_id": 5,
        "correct_answers": [1],
        "explanation": "1 is correct. When dividing ints, remainders are always rounded down. 2, 3, 4, and 5 are incorrect based on the above."
      },
      {
        "question_id": 6,
        "correct_answers": [1],
        "explanation": "1 is correct. All of this syntax is correct. The for-each iterates through the enum using the values() method to return an array. An enum can be compared using either equals() or ==. An enum can be used in a ternary operator's boolean test. 2, 3, 4, 5, 6, and 7 are incorrect based on the above."
      },
      {
        "question_id": 7,
        "correct_answers": [3],
        "explanation": "3 is correct. Line 9 uses the modulus operator, which returns the remainder of the divi- sion, which in this case is 1. Also, line 9 sets b2 to false, and it doesn't test b2's value. Line 10 sets b2 to true, and it doesn’t test its value; however, the short-circuit operator keeps the expression b2 = true from being executed. 1, 2, 4, and 5 are incorrect based on the above. "
      },
      {
        "question_id": 8,
        "correct_answers": [3, 6],
        "explanation": "3 and 6 are correct. At line 7 the || keeps count from being incremented, but the | allows mask to be incremented. At line 8 the ^ returns true only if exactly one operand is true. At line 9 mask is 2 and the && keeps count from being incremented. 1, 2, 4, 5, and 7 are incorrect based on the above. "
      },
      {
        "question_id": 9,
        "correct_answers": [4],
        "explanation": "4 is correct. First, remember that instanceof can look up through multiple levels of an inheritance tree. Also remember that instanceof is commonly used before attempt- ing a downcast, so in this case, after line 15, it would be possible to say Speedboat s3 = (Speedboat)b2;. 1, 2, 3, 5, and 6 are incorrect based on the above. "
      }
    ]
  },
  {
    "exam_id": 1,
    "theme_id": 5,
    "theme_content": "Working with string, Arrays and ArrayLists",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [1, 4],
        "explanation": "1 and 4 are correct. The String operations are working on a new (lost) String not String s. The StringBuilder operations work from left to right. 2, 3, and 5 are incorrect based on the above. "
      },
      {
        "question_id": 2,
        "correct_answers": [4],
        "explanation": "4 is correct. The horses array's first four elements contain Strings, but the fifth is null, so the toUpperCase() invocation for the fifth element throws a NullPointerException. 1, 2, 3, 5, and 6 are incorrect based on the above. "
      },
      {
        "question_id": 3,
        "correct_answers": [5],
        "explanation": "5 is correct. The Unicode declaration must be enclosed in single quotes: '\\u004e'. If this were done, the answer would be A, but knowing that equality isn't on the OCA exam. 1, 2, 3, and 4 are incorrect based on the above."
      },
      {
        "question_id": 4,
        "correct_answers": [3],
        "explanation": "3 is correct. A ClassCastException is thrown at line 7 because o1 refers to an int[][], not an int[]. If line 7 were removed, the output would be 4. 1, 2, 4, 5, 6, and 7 are incorrect based on the above."
      },
      {
        "question_id": 5,
        "correct_answers": [2],
        "explanation": "2 is correct. ArrayList elements are automatically inserted in the order of entry; they are not automatically sorted. ArrayLists use zero-based indexes and the last add() inserts a new element and shifts the remaining elements back. 1, 3, 4, 5, 6, and 7 are incorrect based on the above."
      },
      {
        "question_id": 6,
        "correct_answers": [3, 6],
        "explanation": "3 and 6 are correct. da refers to an object of type \"Dozens array\" and each Dozens object that is created comes with its own \"int array\" object. When line 14 is reached, only the second Dozens object (and its \"int array\" object) are not reachable. 1, 2, 4, 5, and 7 are incorrect based on the above. "
      },
      {
        "question_id": 7,
        "correct_answers": [3],
        "explanation": "3 is correct. A two-dimensional array is an \"array of arrays.\" The length of ba is 2 because it contains two, one-dimensional arrays. Array indexes are zero-based, so ba[1] refers to ba's second array. 1, 2, 4, 5, 6, and 7 are incorrect based on the above. "
      },
      {
        "question_id": 8,
        "correct_answers": [4, 6],
        "explanation": "4 and 6 are correct. Although String objects are immutable, references to Strings are mutable. The code s1 += \"d\"; creates a new String object. StringBuilder objects are mutable, so the append() is changing the single StringBuilder object to which both StringBuilder references refer. 1, 2, 3, 5, and 7 are incorrect based on the above."
      },
      {
        "question_id": 9,
        "correct_answers": [2],
        "explanation": "2 is correct. StringBuilders are mutable, so all of the append() invocations are acting upon the same StringBuilder object over and over. Strings, however, are immutable, so every String concatenation operation results in a new String object. Also, the string \" \" is created once and reused in every loop iteration. 1, 3, 4, and 5 are incorrect based on the above. "
      },
      {
        "question_id": 10,
        "correct_answers": [1],
        "explanation": "1 is correct. Although main()'s b1 is a different reference variable than go()'s b1, they refer to the same Box object. 2, 3, 4, 5, and 6 are incorrect based on the above. "
      },
      {
        "question_id": 11,
        "correct_answers": [4],
        "explanation": "4 is correct. The substring() invocation uses a zero-based index and the second argument is exclusive, so the character at index 8 is NOT included. The toUpperCase() invocation makes a new String object that is instantly lost. The toUpperCase() invocation does NOT affect the String referred to by s. 1, 2, 3, 5, 6, and 7 are incorrect based on the above."
      },
      {
        "question_id": 12,
        "correct_answers": [6],
        "explanation": "6 is correct. When encapsulating a mutable object like an ArrayList, your getter must return a reference to a copy of the object, not just the reference to the original object. 1, 2, 3, 4, 5, and 7 are incorrect based on the above."
      }
    ]
  },
  {
    "exam_id": 1,
    "theme_id": 6,
    "theme_content": "Flow Control and Exceptions",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [1],
        "explanation": "1 is correct. As of Java 7 the code is legal, but the substring() method's second argument is exclusive. If the invocation had been substring(1,4), the output would have been –rg. Note: We hope you won't have too many exam questions that focus on API trivia like this one. If you knew the switch was legal, give yourself \"almost full credit.\" 2, 3, 4, and 5 are incorrect based on the above."
      },
      {
        "question_id": 2,
        "correct_answers": [2],
        "explanation": "2 is correct. Once s3() throws the exception to s2(), s2() throws it to s1(), and no more of s2()'s code will be executed. 1, 3, 4, 5, 6, 7, and 8 are incorrect based on the above."
      },
      {
        "question_id": 3,
        "correct_answers": [3, 4],
        "explanation": "3 and 4 are correct. Integer.parseInt can throw a NumberFormatException, and IllegalArgumentException is its superclass (that is, a broader exception). 1, 2, 5, and 6 are not in NumberFormatException's class hierarchy."
      },
      {
        "question_id": 4,
        "correct_answers": [5],
        "explanation": "5 is correct. As of Java 7 the syntax is legal. The sa[] array receives only three arguments from the command line, so on the last iteration through sa[], a NullPointerException is thrown. 1, 2, 3, and 4 are incorrect based on the above."
      },
      {
        "question_id": 5,
        "correct_answers": [1, 4, 6],
        "explanation": "1, 4, and 6 are correct. 1 is an example of the enhanced for loop. 4 and 6 are examples of the basic for loop. 2, 3, and 5 are incorrect. 2 is incorrect because its operands are swapped. 3 is incorrect because the enhanced for must declare its first operand. 5 is incorrect syntax to declare two variables in a for statement."
      },
      {
        "question_id": 6,
        "correct_answers": [5],
        "explanation": "5 is correct. There is no problem nesting try/catch blocks. As is normal, when an exception is thrown, the code in the catch block runs, and then the code in the finally block runs. 1, 2, 3, 4, and 6 are incorrect based on the above. "
      },
      {
        "question_id": 7,
        "correct_answers": [3],
        "explanation": "3 is correct. An overriding method cannot throw a broader exception than the method it's overriding. Class CC4's method is an overload, not an override. 1, 2, 4, and 5 are incorrect based on the above."
      },
      {
        "question_id": 8,
        "correct_answers": [4],
        "explanation": "4 is correct. Did you catch the static initializer block? Remember that switches work on \"fall-through\" logic, and that fall-through logic also applies to the default case, which is used when no other case matches. 1, 2, 3, 5, 6, and 7 are incorrect based on the above."
      },
      {
        "question_id": 9,
        "correct_answers": [4, 5],
        "explanation": "4 and 5 are correct. Because i was not initialized, case 1 will throw a NullPointerException. Case 0 will initiate an endless loop, not a stack overflow. Case 2's downcast will not cause an exception. 1, 2, 3, 5, and 7 are incorrect based on the above."
      },
      {
        "question_id": 10,
        "correct_answers": [4],
        "explanation": "4 is correct. The basic rule for unlabeled continue statements is that the current iteration stops early and execution jumps to the next iteration. The last two continue statements are redundant! 1, 2, 3, 5, and 6 are incorrect based on the above."
      },
      {
        "question_id": 11,
        "correct_answers": [8],
        "explanation": "8 is correct. It's true that the value of String s is 123 at the time that the divide-by-zero exception is thrown, but finally() is not guaranteed to complete, and in this case finally() never completes, so the System.out.println (S.O.P) never executes. 1, 2, 3, 4, 5, 6, and 7 are incorrect based on the above. "
      },
      {
        "question_id": 12,
        "correct_answers": [3],
        "explanation": "3 is correct. A break breaks out of the current innermost loop and carries on. A labeled break breaks out of and terminates the labeled loops. 1, 2, 4, 5, and 6 are incorrect based on the above. "
      },
      {
        "question_id": 13,
        "correct_answers": [2, 5],
        "explanation": "2 and 5 are correct. First off, go() is a badly designed recursive method, guaranteed to cause a StackOverflowError. Since Exception is not a superclass of Error, catching an Exception will not help handle an Error, so fragment III will not complete normally. Only fragment II will catch the Error. 1, 3, 4, and 6 are incorrect based on the above. "
      },
      {
        "question_id": 14,
        "correct_answers": [5],
        "explanation": "5 is correct. A switch's cases must be compile-time constants or enum values. 1, 2, 3, 4, 6, and 7 are incorrect based on the above. "
      },
      {
        "question_id": 15,
        "correct_answers": [4],
        "explanation": "4 is correct. This is kind of sneaky, but remember that we're trying to toughen you up for the real exam. If you're going to throw an IOException, you have to import the java.io package or declare the exception with a fully qualified name. 1, 2, 3, and 5 are incorrect. 1, 2, and 3 are incorrect based on the above. 5 is incorrect because it's okay both to handle and declare an exception. "
      },
      {
        "question_id": 16,
        "correct_answers": [3, 4],
        "explanation": "3 and 4 are correct. An overriding method cannot throw checked exceptions that are broader than those thrown by the overridden method. However, an overriding method can throw RuntimeExceptions not thrown by the overridden method. 1, 2, 5, and 6 are incorrect based on the above. "
      }
    ]
  },
  {
    "exam_id": 2,
    "theme_id": 7,
    "theme_content": "Assertions and Java 7 Exceptions",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [2, 6],
        "explanation": "2 and 6 are correct. class One will compile (and issue a warning) using the 1.3 flag, and class Two will compile using the 1.4 flag. 1, 3, 4, and 5 are incorrect based on the above. "
      },
      {
        "question_id": 2,
        "correct_answers": [3, 4, 5],
        "explanation": "3, 4, and 5 are correct statements. 1 is incorrect. It is acceptable to use assertions to test the arguments of private methods. 2 is incorrect. While assertion errors can be caught, Oracle discourages you from doing so."
      },
      {
        "question_id": 3,
        "correct_answers": [5],
        "explanation": "5 is correct. When an assert statement has two expressions, the second expression must return a value. The only two-expression assert statement that doesn't return a value is on line 9. 1, 2, 3, 4, and 6 are incorrect based on the above."
      },
      {
        "question_id": 4,
        "correct_answers": [5],
        "explanation": "5 is correct. catch (IOException e | SQLException e) doesn't compile. While multiple exception types can be specified in the multi-catch, only one variable name is allowed. The correct syntax is catch (IOException | SQLException e). Other than this, the code is valid. Note that it is legal for blowUp() to have IOException in its signature even though that Exception can't be thrown. 1, 2, 3, 4, and 6 are incorrect based on the above. If the catch block's syntax error were corrected, the code would output cd. The multi-catch would catch the SQLException from blowUp() since it is one of the exception types listed. And, of course, the finally block runs at the end of the try/catch. "
      },
      {
        "question_id": 5,
        "correct_answers": [3, 4, 7],
        "explanation": "3, 4, and 7 are correct. Since order doesn't matter, both D and G show correct use of the multi-catch block. And C catches the IOException from fileBlowUp() directly. Note that databaseBlowUp() is never called at runtime. However, if you remove the call, the compiler won't let you catch the SQLException since it would be impossible to be thrown. 1 is incorrect because it will not compile. Since there is already a catch block for Exception, adding another will make the compiler think there is unreachable code. 2 is incorrect because it will print c rather than b. Since FileNotFoundException is a subclass of IOException, the thrown IOException will not match the catch block for FileNotFoundException. 5 and 8 are incorrect because they are invalid syntax for multi- catch. The catch parameter e can only appear once. 6 is incorrect because it will print c rather than b. Since the IOException thrown by fileBlowUp() is never caught, the thrown exception will match the catch block for Exception. "
      },
      {
        "question_id": 6,
        "correct_answers": [2, 4, 6],
        "explanation": "2, 4, and 6 are correct. 2 uses multi-catch to identify both exceptions drive() may throw. 4 still compiles since it uses the new enhanced exception typing to recognize that Exception may only refer to AnotherTrainComing and RanOutOfTrack. 6 is the simple case that catches a single exception. Since main throws AnotherTrainComing, the catch block doesn't need to handle it. 1 and 5 are incorrect because the catch block will not handle RanOutOfTrack when drive() throws it. The main method will still throw the exception, but the println() will not run. 3 is incorrect because it is invalid syntax for multi-catch. The catch parameter e can only appear once. 7 is incorrect because of the above. "
      },
      {
        "question_id": 7,
        "correct_answers": [5],
        "explanation": "5 is correct. After the exception is thrown, Automatic Resource Management calls close() before completing the try block. From that point, catch and finally execute in the normal order. 6 is incorrect because the catch block catches the exception and does not rethrow it. 1, 2, 3, 4, and 6 are incorrect because of the above."
      },
      {
        "question_id": 8,
        "correct_answers": [7],
        "explanation": "7 is correct. System.out.println cannot be in the declaration clause of a try-with- resources block because it does not declare a variable. If the println was removed, the answer would be A because resources are closed in the opposite order they are created. 1, 2, 3, 4, 5, and 6 are incorrect because of the above. "
      },
      {
        "question_id": 9,
        "correct_answers": [1, 4],
        "explanation": "1 and 4 are correct. If the code is left with no changes, it will not compile because try-with-resources requires Lamb to implement AutoCloseable or a subinterface. If C2 is implemented, the code will not compile because close() throws Exception instead of IOException. Unlike the traditional try, try-with-resources does not require catch or finally to present. So the code works equally well with or without C3. 2, 3, 5, and 6 are incorrect because of the above. "
      },
      {
        "question_id": 10,
        "correct_answers": [4],
        "explanation": "4 is correct. While the exception caught by the catch block matches choice 1, it is ignored by the catch block. The catch block just throws RuntimeException c without any suppressed exceptions. 1, 2, 3, 5, 6, and 7 are incorrect because of the above."
      },
      {
        "question_id": 11,
        "correct_answers": [1],
        "explanation": "1 is correct. After the try block throws an IOException, Automatic Resource Management calls close() to clean up the resources. Since an exception was already thrown in the try block, RuntimeException a gets added to it as a suppressed exception. The catch block merely rethrows the caught exception. The code does compile even though the catch block catches an Exception and the method merely throws an IOException. In Java 7, the compiler is able to pick up on this. 2, 3, 4, 5, 6, and 7 are incorrect because of the above. "
      },
      {
        "question_id": 12,
        "correct_answers": [6],
        "explanation": "6 is correct. The exception variable in a catch block may not be reassigned when using multi-catch. It CAN be reassigned if we are only catching one exception. 3 would have been correct if e = new PowerOutage(); were removed. 1, 2, 4, and 5 are incorrect because of the above."
      }
    ]
  },
  {
    "exam_id": 2,
    "theme_id": 8,
    "theme_content": "String, Data Formatting, Resource Bundles",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [5],
        "explanation": "5 is correct. The \\d is looking for digits. The * is a quantifier that looks for 0 to many occurrences of the pattern that precedes it. Because we specified *, the group()method returns empty strings until consecutive digits are found, so the only time group() returns a value is when it returns 34, when the matcher finds digits starting in position 2. The start() method returns the starting position of the previous match because, again, we said find 0 to many occurrences. 1, 2, 3, 4, 6, and 7 are incorrect based on the above. "
      },
      {
        "question_id": 2,
        "correct_answers": [1, 3, 4, 5],
        "explanation": "1, 3, 4, and 5 are correct. The default Locale is irrelevant here since none of the choices use Italian. 1 is the default resource bundle. 3 and 4 use the language but not the country from the requested locale. 5 uses the exact match of the requested locale. 2 is incorrect because the language code of CA does not match en. And CA isn't a valid language code. 6 is incorrect because the language code \"fr\" does not match en. Even though the country code of CA does match, the language code is more important."
      },
      {
        "question_id": 3,
        "correct_answers": [2],
        "explanation": "2 is correct. Remember that the boundary metacharacters (\\b and \\B), act as though the string being searched is bounded with invisible, non-word characters. Then remember that \\B reports on boundaries between word to word or non-word to non-word characters. 1, 3, 4, 5, 6, and 7 are incorrect based on the above. "
      },
      {
        "question_id": 4,
        "correct_answers": [2],
        "explanation": "2 is correct. In the second case, the first token is empty. Remember that in the first case, the delimiter is a space, and in the second case, the delimiter is any numeric digit. 1, 3, 4, and 5 are incorrect based on the above. "
      },
      {
        "question_id": 5,
        "correct_answers": [4],
        "explanation": "4 is correct. As is, the code finds resource bundle Train_en_US.properties, which uses Train_en.properties as a parent. Choice 4 finds resource bundle Train_en_UK.properties, which uses Train_en.properties as a parent. 1 is incorrect because both the parent and child have the same property. In this scenario, the more specific one (child) gets used. 2 is incorrect because the default locale only gets used if the requested resource bundle can't be found. 3 is incorrect because it finds the resource bundle Train_en.properties, which does not have any \"train\" key. 5 is incorrect because there is no \"ride\" key once we delete the parent. 6 is incorrect based on the above. "
      },
      {
        "question_id": 6,
        "correct_answers": [3],
        "explanation": "3 is correct. The append()method appends to the end of the StringBuilder's current value, and if you append past the current capacity, the capacity is automatically increased. Note: Invoking insert() past the current capacity will cause an exception to be thrown. 1, 2, 4, 5, and 6 are incorrect based on the above. "
      },
      {
        "question_id": 7,
        "correct_answers": [3, 5],
        "explanation": "3 and 5 are correct. When getting a key from a resource bundle, the key must be a string. The returned result must be a string or an object. While that object may happen to be an integer, the API is still getObject(). 5 will throw a ClassCastException since 456 is not a string, but it will compile. 1, 2, 4, and 6 are incorrect because of the above."
      },
      {
        "question_id": 8,
        "correct_answers": [4, 6],
        "explanation": "4 and 6 are correct. While String objects are immutable, references to Strings are mutable. The code s1 += \"d\"; creates a new String object. StringBuffer objects are mutable, so the append() is changing the single StringBuffer object to which both StringBuffer references refer. 1, 2, 3, 5, and 7 are incorrect based on the above. "
      },
      {
        "question_id": 9,
        "correct_answers": [3],
        "explanation": "3 is correct. The concat() method adds to the end of the String, not the front. The trickier part is the return statement. Remember that Strings are immutable. The String referred to by \"s\" in doStuff() is not changed by the trim() method. Instead, a new String object is created via the trim() method, and a reference to that new String is returned to main(). 1, 2, 4, and 5 are incorrect based on the above."
      },
      {
        "question_id": 10,
        "correct_answers": [4,6,7],
        "explanation": "4, 6, and 7 are correct. The setMaximumFractionDigits() applies to the formatting, but not the parsing. The try/catch block is placed appropriately. This one might scare you into thinking that you'll need to memorize more than you really do. If you can remember that you're formatting the number and parsing the string, you should be fine for the exam. 1, 2, 3, and 5 are incorrect based on the above."
      },
      {
        "question_id": 11,
        "correct_answers": [2],
        "explanation": "2 is correct. The \"\\d\" metacharacter looks for digits, and the + quantifier says look for \"one or more\" occurrences. The find() method will find three sets of one or more consecutive digits: 2, 4, and 67. 1, 3, 4, 5, and 6 are incorrect based on the above. "
      },
      {
        "question_id": 12,
        "correct_answers": [6],
        "explanation": "6 is correct. The nextXxx() methods are typically invoked after a call to a hasNextXxx(), which determines whether the next token is of the correct type. 1, 2, 3, 4, and 5 are incorrect based on the above. "
      }
    ]
  },
  {
    "exam_id": 2,
    "theme_id": 9,
    "theme_content": "I/O and NIO",
    "questions": [
    ]
  },
  {
    "exam_id": 2,
    "theme_id": 10,
    "theme_content": "Advanced OO and Design Patterns",
    "questions": [
    ]
  },
  {
    "exam_id": 2,
    "theme_id": 11,
    "theme_content": "Generics and Collections",
    "questions": [
    ]
  },
  {
    "exam_id": 2,
    "theme_id": 12,
    "theme_content": "Inner Classes",
    "questions": [
    ]
  },
  {
    "exam_id": 2,
    "theme_id": 13,
    "theme_content": "Threads",
    "questions": [
    ]
  },
  {
    "exam_id": 2,
    "theme_id": 14,
    "theme_content": "Concurrency",
    "questions": [
    ]
  },
  {
    "exam_id": 2,
    "theme_id": 15,
    "theme_content": "JDBC",
    "questions": [
    ]
  }
]
