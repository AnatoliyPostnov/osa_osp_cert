[
  {
    "theme_id": 1,
    "theme_content": "Declarations and Access Control",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [3],
        "explanation": "1 is incorrect because classes implement interfaces, they don't extend them. 2 is incorrect because interfaces only \"inherit from\" other interfaces. 4 is incorrect based on the preceding rules."
      },
      {
        "question_id": 2,
        "correct_answers": [2, 6],
        "explanation": "2 and 6 are correct. Since Rocket.blastOff() is private, it can't be overridden, and it is invisible to class Shuttle. 1, 3, 4, and 5 are incorrect based on the above."
      },
      {
        "question_id": 3,
        "correct_answers": [2],
        "explanation": "2 is correct. This question is using valid (but inappropriate and weird) identifiers, static imports, main(), and pre-incrementing logic. 1, 3, 4, 5, 6, and 7 are incorrect based on the above."
      },
      {
        "question_id": 4,
        "correct_answers": [1],
        "explanation": "1 is correct; enums can have constructors and variables. 2, 3, 4, 5, and 6 are incorrect; these lines all use correct syntax."
      },
      {
        "question_id": 5,
        "correct_answers": [4, 5],
        "explanation": "4 and 5 are correct. Variable a has default access, so it cannot be accessed from outside the package. Variable b has protected access in pkgA. 1, 2, 3, and 6 are incorrect based on the above information."
      },
      {
        "question_id": 6,
        "correct_answers": [1],
        "explanation": "1 is correct; all of these are legal declarations. 2, 3, 4, 5, and 6 are incorrect based on the above information. "
      },
      {
        "question_id": 7,
        "correct_answers": [3, 4],
        "explanation": "3, 4 are correct. Variable names cannot begin with #, and an array declaration can't include a size without an instantiation. The rest of the code is valid. 1, 2, and 5 are incorrect based on the above."
      },
      {
        "question_id": 8,
        "correct_answers": [2],
        "explanation": "2 is correct. Every enum comes with a static values() method that returns an array of the enum's values, in the order in which they are declared in the enum. 1, 3, 4, 5, 6, and 7 are incorrect based on the above information. "
      },
      {
        "question_id": 9,
        "correct_answers": [4],
        "explanation": "4 is correct. The countGold() method cannot be invoked from a static context. 1, 2, 3, and 5 are incorrect based on the above information."
      },
      {
        "question_id": 10,
        "correct_answers": [1],
        "explanation": "1 is correct. By default, an interface's methods are public so the Tablet.doStuff method must be public, too. The rest of the code is valid. 2, 3, 4, and 5 are incorrect based on the above."
      },
      {
        "question_id": 11,
        "correct_answers": [3, 5],
        "explanation": "3 and 5 are correct syntax for static imports. Line 4 isn't making use of static imports, so the code will also compile with none of the imports. 1, 2, 4, and 6 are incorrect based on the above. "
      }
    ]
  },
  {
    "theme_id": 2,
    "theme_content": "Declarations and Access Control",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [2, 5],
        "explanation": "2 and 5 are correct. 2 is correct because an abstract class need not implement any or all of an interface's methods. 5 is correct because the class implements the interface method and additionally overloads the twiddle() method. 1, 3, and 4 are incorrect. 1 is incorrect because abstract methods have no body. 3 is incorrect because classes implement interfaces; they don't extend them. 4 is incorrect because overloading a method is not implementing it. "
      },
      {
        "question_id": 2,
        "correct_answers": [5],
        "explanation": "5 is correct. The implied super() call in Bottom2's constructor cannot be satisfied because there is no no-arg constructor in Top. A default, no-arg constructor is generated by the compiler only if the class has no constructor defined explicitly. 1, 2, 3, and 4 are incorrect based on the above."
      },
      {
        "question_id": 3,
        "correct_answers": [1],
        "explanation": "1 is correct. Although a final method cannot be overridden, in this case, the method is private, and therefore hidden. The effect is that a new, accessible, method flipper is created. Therefore, no polymorphism occurs in this example, the method invoked is simply that of the child class, and no error occurs. 2, 3, 4, and 5 are incorrect based on the preceding. "
      },
      {
        "question_id": 4,
        "correct_answers": [4],
        "explanation": "4 is correct. Static init blocks are executed at class loading time; instance init blocks run right after the call to super() in a constructor. When multiple init blocks of a single type occur in a class, they run in order, from the top down. 1, 2, 3, 5, 6, 7, 8, and 9 are incorrect based on the above. Note: You'll probably never see this many choices on the real exam! "
      },
      {
        "question_id": 5,
        "correct_answers": [3],
        "explanation": "3 is correct. Before you can invoke Y's do2 method, you have to cast x2 to be of type Y. 1, 2, and 4 are incorrect based on the preceding. B looks like a proper cast, but without the second set of parentheses, the compiler thinks it's an incomplete statement."
      },
      {
        "question_id": 6,
        "correct_answers": [1],
        "explanation": "1 is correct. It's legal to overload main(). Since no instances of Locomotive are created, the constructor does not run and the overloaded version of main() does not run. 2, 3, 4, and 5 are incorrect based on the preceding. "
      },
      {
        "question_id": 7,
        "correct_answers": [6],
        "explanation": "6 is correct. Class Dog doesn't have a sniff method. 1, 2, 3, 4, and 5 are incorrect based on the above information."
      },
      {
        "question_id": 8,
        "correct_answers": [1],
        "explanation": "1 is correct. A ClassCastException will be thrown when the code attempts to downcast a Tree to a Redwood. 2, 3, 4, 5, and 6 are incorrect based on the above information."
      },
      {
        "question_id": 9,
        "correct_answers": [2],
        "explanation": "2 is correct. The code is correct, but polymorphism doesn't apply to static methods. 1, 3, 4, and 5 are incorrect based on the above information."
      },
      {
        "question_id": 10,
        "correct_answers": [3],
        "explanation": "3 is correct. Watch out, because SubSubAlpha extends Alpha! Since the code doesn't attempt to make a SubAlpha, the private constructor in SubAlpha is okay. 1, 2, 4, 5, and 6 are incorrect based on the above information."
      },
      {
        "question_id": 11,
        "correct_answers": [3],
        "explanation": "3 is correct. Remember that constructors call their superclass constructors, which execute first, and that constructors can be overloaded. 1, 2, 4, 5, 6, 7, and 8 are incorrect based on the above information."
      },
      {
        "question_id": 12,
        "correct_answers": [1],
        "explanation": "1 is correct. Polymorphism is only for instance methods, not instance variables. 2, 3, 4, 5, and 6 are incorrect based on the above information."
      },
      {
        "question_id": 13,
        "correct_answers": [1, 3],
        "explanation": "1 and 3 are correct. The phrase \"type of\" indicates an IS-A relationship (extends or implements), and the word \"have\" of course indicates a HAS-A relationship (usually instance variables). 2 and 4 are incorrect based on the above information. "
      }
    ]
  }
]