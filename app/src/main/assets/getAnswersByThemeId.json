[
  {
    "exam_id": 1,
    "theme_id": 1,
    "theme_content": "Declarations and Access Control",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [3],
        "explanation": "1 is incorrect because classes implement interfaces, they don't extend them. 2 is incorrect because interfaces only \"inherit from\" other interfaces. 4 is incorrect based on the preceding rules."
      },
      {
        "question_id": 2,
        "correct_answers": [2, 6],
        "explanation": "2 and 6 are correct. Since Rocket.blastOff() is private, it can't be overridden, and it is invisible to class Shuttle. 1, 3, 4, and 5 are incorrect based on the above."
      },
      {
        "question_id": 3,
        "correct_answers": [2],
        "explanation": "2 is correct. This question is using valid (but inappropriate and weird) identifiers, static imports, main(), and pre-incrementing logic. 1, 3, 4, 5, 6, and 7 are incorrect based on the above."
      },
      {
        "question_id": 4,
        "correct_answers": [1],
        "explanation": "1 is correct; enums can have constructors and variables. 2, 3, 4, 5, and 6 are incorrect; these lines all use correct syntax."
      },
      {
        "question_id": 5,
        "correct_answers": [4, 5],
        "explanation": "4 and 5 are correct. Variable a has default access, so it cannot be accessed from outside the package. Variable b has protected access in pkgA. 1, 2, 3, and 6 are incorrect based on the above information."
      },
      {
        "question_id": 6,
        "correct_answers": [1],
        "explanation": "1 is correct; all of these are legal declarations. 2, 3, 4, 5, and 6 are incorrect based on the above information. "
      },
      {
        "question_id": 7,
        "correct_answers": [3, 4],
        "explanation": "3, 4 are correct. Variable names cannot begin with #, and an array declaration can't include a size without an instantiation. The rest of the code is valid. 1, 2, and 5 are incorrect based on the above."
      },
      {
        "question_id": 8,
        "correct_answers": [2],
        "explanation": "2 is correct. Every enum comes with a static values() method that returns an array of the enum's values, in the order in which they are declared in the enum. 1, 3, 4, 5, 6, and 7 are incorrect based on the above information. "
      },
      {
        "question_id": 9,
        "correct_answers": [4],
        "explanation": "4 is correct. The countGold() method cannot be invoked from a static context. 1, 2, 3, and 5 are incorrect based on the above information."
      },
      {
        "question_id": 10,
        "correct_answers": [1],
        "explanation": "1 is correct. By default, an interface's methods are public so the Tablet.doStuff method must be public, too. The rest of the code is valid. 2, 3, 4, and 5 are incorrect based on the above."
      },
      {
        "question_id": 11,
        "correct_answers": [3, 5],
        "explanation": "3 and 5 are correct syntax for static imports. Line 4 isn't making use of static imports, so the code will also compile with none of the imports. 1, 2, 4, and 6 are incorrect based on the above. "
      }
    ]
  },
  {
    "exam_id": 1,
    "theme_id": 2,
    "theme_content": "Declarations and Access Control",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [2, 5],
        "explanation": "2 and 5 are correct. 2 is correct because an abstract class need not implement any or all of an interface's methods. 5 is correct because the class implements the interface method and additionally overloads the twiddle() method. 1, 3, and 4 are incorrect. 1 is incorrect because abstract methods have no body. 3 is incorrect because classes implement interfaces; they don't extend them. 4 is incorrect because overloading a method is not implementing it. "
      },
      {
        "question_id": 2,
        "correct_answers": [5],
        "explanation": "5 is correct. The implied super() call in Bottom2's constructor cannot be satisfied because there is no no-arg constructor in Top. A default, no-arg constructor is generated by the compiler only if the class has no constructor defined explicitly. 1, 2, 3, and 4 are incorrect based on the above."
      },
      {
        "question_id": 3,
        "correct_answers": [1],
        "explanation": "1 is correct. Although a final method cannot be overridden, in this case, the method is private, and therefore hidden. The effect is that a new, accessible, method flipper is created. Therefore, no polymorphism occurs in this example, the method invoked is simply that of the child class, and no error occurs. 2, 3, 4, and 5 are incorrect based on the preceding. "
      },
      {
        "question_id": 4,
        "correct_answers": [4],
        "explanation": "4 is correct. Static init blocks are executed at class loading time; instance init blocks run right after the call to super() in a constructor. When multiple init blocks of a single type occur in a class, they run in order, from the top down. 1, 2, 3, 5, 6, 7, 8, and 9 are incorrect based on the above. Note: You'll probably never see this many choices on the real exam! "
      },
      {
        "question_id": 5,
        "correct_answers": [3],
        "explanation": "3 is correct. Before you can invoke Y's do2 method, you have to cast x2 to be of type Y. 1, 2, and 4 are incorrect based on the preceding. B looks like a proper cast, but without the second set of parentheses, the compiler thinks it's an incomplete statement."
      },
      {
        "question_id": 6,
        "correct_answers": [1],
        "explanation": "1 is correct. It's legal to overload main(). Since no instances of Locomotive are created, the constructor does not run and the overloaded version of main() does not run. 2, 3, 4, and 5 are incorrect based on the preceding. "
      },
      {
        "question_id": 7,
        "correct_answers": [6],
        "explanation": "6 is correct. Class Dog doesn't have a sniff method. 1, 2, 3, 4, and 5 are incorrect based on the above information."
      },
      {
        "question_id": 8,
        "correct_answers": [1],
        "explanation": "1 is correct. A ClassCastException will be thrown when the code attempts to downcast a Tree to a Redwood. 2, 3, 4, 5, and 6 are incorrect based on the above information."
      },
      {
        "question_id": 9,
        "correct_answers": [2],
        "explanation": "2 is correct. The code is correct, but polymorphism doesn't apply to static methods. 1, 3, 4, and 5 are incorrect based on the above information."
      },
      {
        "question_id": 10,
        "correct_answers": [3],
        "explanation": "3 is correct. Watch out, because SubSubAlpha extends Alpha! Since the code doesn't attempt to make a SubAlpha, the private constructor in SubAlpha is okay. 1, 2, 4, 5, and 6 are incorrect based on the above information."
      },
      {
        "question_id": 11,
        "correct_answers": [3],
        "explanation": "3 is correct. Remember that constructors call their superclass constructors, which execute first, and that constructors can be overloaded. 1, 2, 4, 5, 6, 7, and 8 are incorrect based on the above information."
      },
      {
        "question_id": 12,
        "correct_answers": [1],
        "explanation": "1 is correct. Polymorphism is only for instance methods, not instance variables. 2, 3, 4, 5, and 6 are incorrect based on the above information."
      },
      {
        "question_id": 13,
        "correct_answers": [1, 3],
        "explanation": "1 and 3 are correct. The phrase \"type of\" indicates an IS-A relationship (extends or implements), and the word \"have\" of course indicates a HAS-A relationship (usually instance variables). 2 and 4 are incorrect based on the above information. "
      }
    ]
  },
  {
    "exam_id": 1,
    "theme_id": 3,
    "theme_content": "Assignments",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [3],
        "explanation": "3 is correct. Only one CardBoard object (c1) is eligible, but it has an associated Short wrapper object that is also eligible.1, 2, 4, 5, and 6 are incorrect based on the above."
      },
      {
        "question_id": 2,
        "correct_answers": [5],
        "explanation": "5 is correct; compilation of line E fails. When a mathematical operation is performed on any primitives smaller than ints, the result is automatically cast to an integer.1, 2, 3, and 4 are all legal primitive casts. "
      },
      {
        "question_id": 3,
        "correct_answers": [3],
        "explanation": "3 is correct; line C will NOT compile. As of Java 7, underscores can be included in numeric literals, but not at the beginning or the end. 1, 2, 4, 5, and 6 are incorrect. A and B are legal numeric literals. D and E are examples of valid binary literals, which are also new to Java 7, and F is a valid hexadecimal literal that uses an underscore."
      },
      {
        "question_id": 4,
        "correct_answers": [6],
        "explanation": "6 is correct. The m2 object's m1 instance variable is never initialized, so when m5 tries to use it a NullPointerException is thrown. 1, 2, 3, 4, and 5 are incorrect based on the above. "
      },
      {
        "question_id": 5,
        "correct_answers": [1],
        "explanation": "1 is correct. The references f1, z, and f3 all refer to the same instance of Fizz. The final modifier assures that a reference variable cannot be referred to a different object, but final doesn't keep the object's state from changing. 2, 3, 4, 5, and 6 are incorrect based on the above. "
      },
      {
        "question_id": 6,
        "correct_answers": [2],
        "explanation": "2 is correct. In the go() method, m refers to the single Mirror instance, but the int i is a new int variable, a detached copy of i2. 1, 3, 4, 5, and 6 are incorrect based on the above."
      },
      {
        "question_id": 7,
        "correct_answers": [1,2,7],
        "explanation": "1, 2, and 7 are correct. The constructor sets the value of id for w1 and w2. When the commented line is reached, none of the three Wind objects can be accessed, so they are eligible to be garbage collected. 3, 4, 5, and 6 are incorrect based on the above."
      },
      {
        "question_id": 8,
        "correct_answers": [5],
        "explanation": "5 is correct. The parameter declared on line 9 is valid (although ugly), but the variable name ouch cannot be declared again on line 11 in the same scope as the declaration on line 9. 1, 2, 3, 4, and 6 are incorrect based on the above."
      },
      {
        "question_id": 9,
        "correct_answers": [4],
        "explanation": "D is correct. Inside the go() method, h1 is out of scope. 1, 2, 3, and 5 are incorrect based on the above."
      },
      {
        "question_id": 10,
        "correct_answers": [1],
        "explanation": "1 is correct. Three Network objects are created. The n2 object has a reference to the n1 object, and the n3 object has a reference to the n2 object. The S.O.P. can be read as, \"Use the n3 object's Network reference (the first p), to find that object's reference (n2), and use that object's reference (the second p) to find that object's (n1's) id, and print that id.\" 2, 3, 4, and 5 are incorrect based on the above. "
      },
      {
        "question_id": 11,
        "correct_answers": [2],
        "explanation": "2 is correct. It should be clear that there is still a reference to the object referred to by a2, and that there is still a reference to the object referred to by a2.b2. What might be less clear is that you can still access the other Beta object through the static variable a2.b1—because it's static. 1, 3, 4, 5, and 6 are incorrect based on the above."
      },
      {
        "question_id": 12,
        "correct_answers": [2],
        "explanation": "2 is correct. In the Telescope class, there are three different variables named magnify. The go() method's version and the zoomMore() method's version are not used in the zoomIn() method. The zoomIn() method multiplies the class variable * 5. The result (10) is sent to zoomMore(), but what happens in zoomMore() stays in zoomMore(). The S.O.P. prints the value of zoomIn()'s magnify. 1, 3, 4, 5, 6, and 7 are incorrect based on the above. "
      },
      {
        "question_id": 13,
        "correct_answers": [5],
        "explanation": "5 is correct. In go1() the local variable x is not initialized. 1, 2, 3, 4, and 6 are incorrect based on the above."
      }
    ]
  },
  {
    "exam_id": 1,
    "theme_id": 4,
    "theme_content": "Operations",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [4],
        "explanation": "4 is correct. This is a ternary nested in a ternary. Both of the ternary expressions are false. 1, 2, 3, 5, and 6 are incorrect based on the above."
      },
      {
        "question_id": 2,
        "correct_answers": [3],
        "explanation": "3 is correct. The == operator tests for reference variable equality, not object equality. 1, 2, 4, 5, and 6 are incorrect based on the above."
      },

      {
        "question_id": 3,
        "correct_answers": [5],
        "explanation": "5 is correct. Because the short circuit (||) is not used, both operands are evaluated. Since args[1] is past the args array bounds, an ArrayIndexOutOfBoundsException is thrown. 1, 2, 3, and 4 are incorrect based on the above."
      },
      {
        "question_id": 4,
        "correct_answers": [7],
        "explanation": "7 is correct. Concatenation runs from left to right, and if either operand is a String, the operands are concatenated. If both operands are numbers, they are added together. 1, 2, 3, 4, 5, 6, 8, and 9 are incorrect based on the above."
      },
      {
        "question_id": 5,
        "correct_answers": [1],
        "explanation": "1 is correct. When dividing ints, remainders are always rounded down. 2, 3, 4, and 5 are incorrect based on the above."
      },
      {
        "question_id": 6,
        "correct_answers": [1],
        "explanation": "1 is correct. All of this syntax is correct. The for-each iterates through the enum using the values() method to return an array. An enum can be compared using either equals() or ==. An enum can be used in a ternary operator's boolean test. 2, 3, 4, 5, 6, and 7 are incorrect based on the above."
      },
      {
        "question_id": 7,
        "correct_answers": [3],
        "explanation": "3 is correct. Line 9 uses the modulus operator, which returns the remainder of the divi- sion, which in this case is 1. Also, line 9 sets b2 to false, and it doesn't test b2's value. Line 10 sets b2 to true, and it doesn’t test its value; however, the short-circuit operator keeps the expression b2 = true from being executed. 1, 2, 4, and 5 are incorrect based on the above. "
      },
      {
        "question_id": 8,
        "correct_answers": [3, 6],
        "explanation": "3 and 6 are correct. At line 7 the || keeps count from being incremented, but the | allows mask to be incremented. At line 8 the ^ returns true only if exactly one operand is true. At line 9 mask is 2 and the && keeps count from being incremented. 1, 2, 4, 5, and 7 are incorrect based on the above. "
      },
      {
        "question_id": 9,
        "correct_answers": [4],
        "explanation": "4 is correct. First, remember that instanceof can look up through multiple levels of an inheritance tree. Also remember that instanceof is commonly used before attempt- ing a downcast, so in this case, after line 15, it would be possible to say Speedboat s3 = (Speedboat)b2;. 1, 2, 3, 5, and 6 are incorrect based on the above. "
      }
    ]
  },
  {
    "exam_id": 1,
    "theme_id": 5,
    "theme_content": "Working with string, Arrays and ArrayLists",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [1, 4],
        "explanation": "1 and 4 are correct. The String operations are working on a new (lost) String not String s. The StringBuilder operations work from left to right. 2, 3, and 5 are incorrect based on the above. "
      },
      {
        "question_id": 2,
        "correct_answers": [4],
        "explanation": "4 is correct. The horses array's first four elements contain Strings, but the fifth is null, so the toUpperCase() invocation for the fifth element throws a NullPointerException. 1, 2, 3, 5, and 6 are incorrect based on the above. "
      },
      {
        "question_id": 3,
        "correct_answers": [5],
        "explanation": "5 is correct. The Unicode declaration must be enclosed in single quotes: '\\u004e'. If this were done, the answer would be A, but knowing that equality isn't on the OCA exam. 1, 2, 3, and 4 are incorrect based on the above."
      },
      {
        "question_id": 4,
        "correct_answers": [3],
        "explanation": "3 is correct. A ClassCastException is thrown at line 7 because o1 refers to an int[][], not an int[]. If line 7 were removed, the output would be 4. 1, 2, 4, 5, 6, and 7 are incorrect based on the above."
      },
      {
        "question_id": 5,
        "correct_answers": [2],
        "explanation": "2 is correct. ArrayList elements are automatically inserted in the order of entry; they are not automatically sorted. ArrayLists use zero-based indexes and the last add() inserts a new element and shifts the remaining elements back. 1, 3, 4, 5, 6, and 7 are incorrect based on the above."
      },
      {
        "question_id": 6,
        "correct_answers": [3, 6],
        "explanation": "3 and 6 are correct. da refers to an object of type \"Dozens array\" and each Dozens object that is created comes with its own \"int array\" object. When line 14 is reached, only the second Dozens object (and its \"int array\" object) are not reachable. 1, 2, 4, 5, and 7 are incorrect based on the above. "
      },
      {
        "question_id": 7,
        "correct_answers": [3],
        "explanation": "3 is correct. A two-dimensional array is an \"array of arrays.\" The length of ba is 2 because it contains two, one-dimensional arrays. Array indexes are zero-based, so ba[1] refers to ba's second array. 1, 2, 4, 5, 6, and 7 are incorrect based on the above. "
      },
      {
        "question_id": 8,
        "correct_answers": [4, 6],
        "explanation": "4 and 6 are correct. Although String objects are immutable, references to Strings are mutable. The code s1 += \"d\"; creates a new String object. StringBuilder objects are mutable, so the append() is changing the single StringBuilder object to which both StringBuilder references refer. 1, 2, 3, 5, and 7 are incorrect based on the above."
      },
      {
        "question_id": 9,
        "correct_answers": [2],
        "explanation": "2 is correct. StringBuilders are mutable, so all of the append() invocations are acting upon the same StringBuilder object over and over. Strings, however, are immutable, so every String concatenation operation results in a new String object. Also, the string \" \" is created once and reused in every loop iteration. 1, 3, 4, and 5 are incorrect based on the above. "
      },
      {
        "question_id": 10,
        "correct_answers": [1],
        "explanation": "1 is correct. Although main()'s b1 is a different reference variable than go()'s b1, they refer to the same Box object. 2, 3, 4, 5, and 6 are incorrect based on the above. "
      },
      {
        "question_id": 11,
        "correct_answers": [4],
        "explanation": "4 is correct. The substring() invocation uses a zero-based index and the second argument is exclusive, so the character at index 8 is NOT included. The toUpperCase() invocation makes a new String object that is instantly lost. The toUpperCase() invocation does NOT affect the String referred to by s. 1, 2, 3, 5, 6, and 7 are incorrect based on the above."
      },
      {
        "question_id": 12,
        "correct_answers": [6],
        "explanation": "6 is correct. When encapsulating a mutable object like an ArrayList, your getter must return a reference to a copy of the object, not just the reference to the original object. 1, 2, 3, 4, 5, and 7 are incorrect based on the above."
      }
    ]
  },
  {
    "exam_id": 1,
    "theme_id": 6,
    "theme_content": "Flow Control and Exceptions",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [1],
        "explanation": "1 is correct. As of Java 7 the code is legal, but the substring() method's second argument is exclusive. If the invocation had been substring(1,4), the output would have been –rg. Note: We hope you won't have too many exam questions that focus on API trivia like this one. If you knew the switch was legal, give yourself \"almost full credit.\" 2, 3, 4, and 5 are incorrect based on the above."
      },
      {
        "question_id": 2,
        "correct_answers": [2],
        "explanation": "2 is correct. Once s3() throws the exception to s2(), s2() throws it to s1(), and no more of s2()'s code will be executed. 1, 3, 4, 5, 6, 7, and 8 are incorrect based on the above."
      },
      {
        "question_id": 3,
        "correct_answers": [3, 4],
        "explanation": "3 and 4 are correct. Integer.parseInt can throw a NumberFormatException, and IllegalArgumentException is its superclass (that is, a broader exception). 1, 2, 5, and 6 are not in NumberFormatException's class hierarchy."
      },
      {
        "question_id": 4,
        "correct_answers": [5],
        "explanation": "5 is correct. As of Java 7 the syntax is legal. The sa[] array receives only three arguments from the command line, so on the last iteration through sa[], a NullPointerException is thrown. 1, 2, 3, and 4 are incorrect based on the above."
      },
      {
        "question_id": 5,
        "correct_answers": [1, 4, 6],
        "explanation": "1, 4, and 6 are correct. 1 is an example of the enhanced for loop. 4 and 6 are examples of the basic for loop. 2, 3, and 5 are incorrect. 2 is incorrect because its operands are swapped. 3 is incorrect because the enhanced for must declare its first operand. 5 is incorrect syntax to declare two variables in a for statement."
      },
      {
        "question_id": 6,
        "correct_answers": [5],
        "explanation": "5 is correct. There is no problem nesting try/catch blocks. As is normal, when an exception is thrown, the code in the catch block runs, and then the code in the finally block runs. 1, 2, 3, 4, and 6 are incorrect based on the above. "
      },
      {
        "question_id": 7,
        "correct_answers": [3],
        "explanation": "3 is correct. An overriding method cannot throw a broader exception than the method it's overriding. Class CC4's method is an overload, not an override. 1, 2, 4, and 5 are incorrect based on the above."
      },
      {
        "question_id": 8,
        "correct_answers": [4],
        "explanation": "4 is correct. Did you catch the static initializer block? Remember that switches work on \"fall-through\" logic, and that fall-through logic also applies to the default case, which is used when no other case matches. 1, 2, 3, 5, 6, and 7 are incorrect based on the above."
      },
      {
        "question_id": 9,
        "correct_answers": [4, 5],
        "explanation": "4 and 5 are correct. Because i was not initialized, case 1 will throw a NullPointerException. Case 0 will initiate an endless loop, not a stack overflow. Case 2's downcast will not cause an exception. 1, 2, 3, 5, and 7 are incorrect based on the above."
      },
      {
        "question_id": 10,
        "correct_answers": [4],
        "explanation": "4 is correct. The basic rule for unlabeled continue statements is that the current iteration stops early and execution jumps to the next iteration. The last two continue statements are redundant! 1, 2, 3, 5, and 6 are incorrect based on the above."
      },
      {
        "question_id": 11,
        "correct_answers": [8],
        "explanation": "8 is correct. It's true that the value of String s is 123 at the time that the divide-by-zero exception is thrown, but finally() is not guaranteed to complete, and in this case finally() never completes, so the System.out.println (S.O.P) never executes. 1, 2, 3, 4, 5, 6, and 7 are incorrect based on the above. "
      },
      {
        "question_id": 12,
        "correct_answers": [3],
        "explanation": "3 is correct. A break breaks out of the current innermost loop and carries on. A labeled break breaks out of and terminates the labeled loops. 1, 2, 4, 5, and 6 are incorrect based on the above. "
      },
      {
        "question_id": 13,
        "correct_answers": [2, 5],
        "explanation": "2 and 5 are correct. First off, go() is a badly designed recursive method, guaranteed to cause a StackOverflowError. Since Exception is not a superclass of Error, catching an Exception will not help handle an Error, so fragment III will not complete normally. Only fragment II will catch the Error. 1, 3, 4, and 6 are incorrect based on the above. "
      },
      {
        "question_id": 14,
        "correct_answers": [5],
        "explanation": "5 is correct. A switch's cases must be compile-time constants or enum values. 1, 2, 3, 4, 6, and 7 are incorrect based on the above. "
      },
      {
        "question_id": 15,
        "correct_answers": [4],
        "explanation": "4 is correct. This is kind of sneaky, but remember that we're trying to toughen you up for the real exam. If you're going to throw an IOException, you have to import the java.io package or declare the exception with a fully qualified name. 1, 2, 3, and 5 are incorrect. 1, 2, and 3 are incorrect based on the above. 5 is incorrect because it's okay both to handle and declare an exception. "
      },
      {
        "question_id": 16,
        "correct_answers": [3, 4],
        "explanation": "3 and 4 are correct. An overriding method cannot throw checked exceptions that are broader than those thrown by the overridden method. However, an overriding method can throw RuntimeExceptions not thrown by the overridden method. 1, 2, 5, and 6 are incorrect based on the above. "
      }
    ]
  },
  {
    "exam_id": 2,
    "theme_id": 7,
    "theme_content": "Assertions and Java 7 Exceptions",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [2, 6],
        "explanation": "2 and 6 are correct. class One will compile (and issue a warning) using the 1.3 flag, and class Two will compile using the 1.4 flag. 1, 3, 4, and 5 are incorrect based on the above. "
      },
      {
        "question_id": 2,
        "correct_answers": [3, 4, 5],
        "explanation": "3, 4, and 5 are correct statements. 1 is incorrect. It is acceptable to use assertions to test the arguments of private methods. 2 is incorrect. While assertion errors can be caught, Oracle discourages you from doing so."
      },
      {
        "question_id": 3,
        "correct_answers": [5],
        "explanation": "5 is correct. When an assert statement has two expressions, the second expression must return a value. The only two-expression assert statement that doesn't return a value is on line 9. 1, 2, 3, 4, and 6 are incorrect based on the above."
      },
      {
        "question_id": 4,
        "correct_answers": [5],
        "explanation": "5 is correct. catch (IOException e | SQLException e) doesn't compile. While multiple exception types can be specified in the multi-catch, only one variable name is allowed. The correct syntax is catch (IOException | SQLException e). Other than this, the code is valid. Note that it is legal for blowUp() to have IOException in its signature even though that Exception can't be thrown. 1, 2, 3, 4, and 6 are incorrect based on the above. If the catch block's syntax error were corrected, the code would output cd. The multi-catch would catch the SQLException from blowUp() since it is one of the exception types listed. And, of course, the finally block runs at the end of the try/catch. "
      },
      {
        "question_id": 5,
        "correct_answers": [3, 4, 7],
        "explanation": "3, 4, and 7 are correct. Since order doesn't matter, both D and G show correct use of the multi-catch block. And C catches the IOException from fileBlowUp() directly. Note that databaseBlowUp() is never called at runtime. However, if you remove the call, the compiler won't let you catch the SQLException since it would be impossible to be thrown. 1 is incorrect because it will not compile. Since there is already a catch block for Exception, adding another will make the compiler think there is unreachable code. 2 is incorrect because it will print c rather than b. Since FileNotFoundException is a subclass of IOException, the thrown IOException will not match the catch block for FileNotFoundException. 5 and 8 are incorrect because they are invalid syntax for multi- catch. The catch parameter e can only appear once. 6 is incorrect because it will print c rather than b. Since the IOException thrown by fileBlowUp() is never caught, the thrown exception will match the catch block for Exception. "
      },
      {
        "question_id": 6,
        "correct_answers": [2, 4, 6],
        "explanation": "2, 4, and 6 are correct. 2 uses multi-catch to identify both exceptions drive() may throw. 4 still compiles since it uses the new enhanced exception typing to recognize that Exception may only refer to AnotherTrainComing and RanOutOfTrack. 6 is the simple case that catches a single exception. Since main throws AnotherTrainComing, the catch block doesn't need to handle it. 1 and 5 are incorrect because the catch block will not handle RanOutOfTrack when drive() throws it. The main method will still throw the exception, but the println() will not run. 3 is incorrect because it is invalid syntax for multi-catch. The catch parameter e can only appear once. 7 is incorrect because of the above. "
      },
      {
        "question_id": 7,
        "correct_answers": [5],
        "explanation": "5 is correct. After the exception is thrown, Automatic Resource Management calls close() before completing the try block. From that point, catch and finally execute in the normal order. 6 is incorrect because the catch block catches the exception and does not rethrow it. 1, 2, 3, 4, and 6 are incorrect because of the above."
      },
      {
        "question_id": 8,
        "correct_answers": [7],
        "explanation": "7 is correct. System.out.println cannot be in the declaration clause of a try-with- resources block because it does not declare a variable. If the println was removed, the answer would be A because resources are closed in the opposite order they are created. 1, 2, 3, 4, 5, and 6 are incorrect because of the above. "
      },
      {
        "question_id": 9,
        "correct_answers": [1, 4],
        "explanation": "1 and 4 are correct. If the code is left with no changes, it will not compile because try-with-resources requires Lamb to implement AutoCloseable or a subinterface. If C2 is implemented, the code will not compile because close() throws Exception instead of IOException. Unlike the traditional try, try-with-resources does not require catch or finally to present. So the code works equally well with or without C3. 2, 3, 5, and 6 are incorrect because of the above. "
      },
      {
        "question_id": 10,
        "correct_answers": [4],
        "explanation": "4 is correct. While the exception caught by the catch block matches choice 1, it is ignored by the catch block. The catch block just throws RuntimeException c without any suppressed exceptions. 1, 2, 3, 5, 6, and 7 are incorrect because of the above."
      },
      {
        "question_id": 11,
        "correct_answers": [1],
        "explanation": "1 is correct. After the try block throws an IOException, Automatic Resource Management calls close() to clean up the resources. Since an exception was already thrown in the try block, RuntimeException a gets added to it as a suppressed exception. The catch block merely rethrows the caught exception. The code does compile even though the catch block catches an Exception and the method merely throws an IOException. In Java 7, the compiler is able to pick up on this. 2, 3, 4, 5, 6, and 7 are incorrect because of the above. "
      },
      {
        "question_id": 12,
        "correct_answers": [6],
        "explanation": "6 is correct. The exception variable in a catch block may not be reassigned when using multi-catch. It CAN be reassigned if we are only catching one exception. 3 would have been correct if e = new PowerOutage(); were removed. 1, 2, 4, and 5 are incorrect because of the above."
      }
    ]
  },
  {
    "exam_id": 2,
    "theme_id": 8,
    "theme_content": "String, Data Formatting, Resource Bundles",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [5],
        "explanation": "5 is correct. The \\d is looking for digits. The * is a quantifier that looks for 0 to many occurrences of the pattern that precedes it. Because we specified *, the group()method returns empty strings until consecutive digits are found, so the only time group() returns a value is when it returns 34, when the matcher finds digits starting in position 2. The start() method returns the starting position of the previous match because, again, we said find 0 to many occurrences. 1, 2, 3, 4, 6, and 7 are incorrect based on the above. "
      },
      {
        "question_id": 2,
        "correct_answers": [1, 3, 4, 5],
        "explanation": "1, 3, 4, and 5 are correct. The default Locale is irrelevant here since none of the choices use Italian. 1 is the default resource bundle. 3 and 4 use the language but not the country from the requested locale. 5 uses the exact match of the requested locale. 2 is incorrect because the language code of CA does not match en. And CA isn't a valid language code. 6 is incorrect because the language code \"fr\" does not match en. Even though the country code of CA does match, the language code is more important."
      },
      {
        "question_id": 3,
        "correct_answers": [2],
        "explanation": "2 is correct. Remember that the boundary metacharacters (\\b and \\B), act as though the string being searched is bounded with invisible, non-word characters. Then remember that \\B reports on boundaries between word to word or non-word to non-word characters. 1, 3, 4, 5, 6, and 7 are incorrect based on the above. "
      },
      {
        "question_id": 4,
        "correct_answers": [2],
        "explanation": "2 is correct. In the second case, the first token is empty. Remember that in the first case, the delimiter is a space, and in the second case, the delimiter is any numeric digit. 1, 3, 4, and 5 are incorrect based on the above. "
      },
      {
        "question_id": 5,
        "correct_answers": [4],
        "explanation": "4 is correct. As is, the code finds resource bundle Train_en_US.properties, which uses Train_en.properties as a parent. Choice 4 finds resource bundle Train_en_UK.properties, which uses Train_en.properties as a parent. 1 is incorrect because both the parent and child have the same property. In this scenario, the more specific one (child) gets used. 2 is incorrect because the default locale only gets used if the requested resource bundle can't be found. 3 is incorrect because it finds the resource bundle Train_en.properties, which does not have any \"train\" key. 5 is incorrect because there is no \"ride\" key once we delete the parent. 6 is incorrect based on the above. "
      },
      {
        "question_id": 6,
        "correct_answers": [3],
        "explanation": "3 is correct. The append()method appends to the end of the StringBuilder's current value, and if you append past the current capacity, the capacity is automatically increased. Note: Invoking insert() past the current capacity will cause an exception to be thrown. 1, 2, 4, 5, and 6 are incorrect based on the above. "
      },
      {
        "question_id": 7,
        "correct_answers": [3, 5],
        "explanation": "3 and 5 are correct. When getting a key from a resource bundle, the key must be a string. The returned result must be a string or an object. While that object may happen to be an integer, the API is still getObject(). 5 will throw a ClassCastException since 456 is not a string, but it will compile. 1, 2, 4, and 6 are incorrect because of the above."
      },
      {
        "question_id": 8,
        "correct_answers": [4, 6],
        "explanation": "4 and 6 are correct. While String objects are immutable, references to Strings are mutable. The code s1 += \"d\"; creates a new String object. StringBuffer objects are mutable, so the append() is changing the single StringBuffer object to which both StringBuffer references refer. 1, 2, 3, 5, and 7 are incorrect based on the above. "
      },
      {
        "question_id": 9,
        "correct_answers": [3],
        "explanation": "3 is correct. The concat() method adds to the end of the String, not the front. The trickier part is the return statement. Remember that Strings are immutable. The String referred to by \"s\" in doStuff() is not changed by the trim() method. Instead, a new String object is created via the trim() method, and a reference to that new String is returned to main(). 1, 2, 4, and 5 are incorrect based on the above."
      },
      {
        "question_id": 10,
        "correct_answers": [4,6,7],
        "explanation": "4, 6, and 7 are correct. The setMaximumFractionDigits() applies to the formatting, but not the parsing. The try/catch block is placed appropriately. This one might scare you into thinking that you'll need to memorize more than you really do. If you can remember that you're formatting the number and parsing the string, you should be fine for the exam. 1, 2, 3, and 5 are incorrect based on the above."
      },
      {
        "question_id": 11,
        "correct_answers": [2],
        "explanation": "2 is correct. The \"\\d\" metacharacter looks for digits, and the + quantifier says look for \"one or more\" occurrences. The find() method will find three sets of one or more consecutive digits: 2, 4, and 67. 1, 3, 4, 5, and 6 are incorrect based on the above. "
      },
      {
        "question_id": 12,
        "correct_answers": [6],
        "explanation": "6 is correct. The nextXxx() methods are typically invoked after a call to a hasNextXxx(), which determines whether the next token is of the correct type. 1, 2, 3, 4, and 5 are incorrect based on the above. "
      }
    ]
  },
  {
    "exam_id": 2,
    "theme_id": 9,
    "theme_content": "I/O and NIO",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [1, 2],
        "explanation": "1 and 2 are correct. Because you are invoking the program from the directory whose direct subdirectories are to be searched, you don't start your path with a File.separator character. The exists()method tests for either files or directories; the isFile() method tests only for files. Since we're looking for a file, both methods work. 3 and 4 are incorrect based on the above. "
      },
      {
        "question_id": 2,
        "correct_answers": [5],
        "explanation": "5 is correct. You need to call flush()only when you're writing data. Readers don't have flush() methods. If not for the call to flush(), answer 3 would be correct. 1, 2, 3, and 4 are incorrect based on the above."
      },
      {
        "question_id": 3,
        "correct_answers": [4],
        "explanation": "4 is correct. The readPassword() method returns a char[]. If a char[] were used, answer 2 would be correct. 1, 2, 3, and 5 are incorrect based on the above. "
      },
      {
        "question_id": 4,
        "correct_answers": [1, 2],
        "explanation": "1 and 2 are correct. Dodge instances cannot be serialized because they \"have\" an instance of Wheels, which is not serializable. Vehicle instances cannot be serialized even though the subclass Car can be. 3, 4, and 5 are incorrect based on the above. "
      },
      {
        "question_id": 5,
        "correct_answers": [5, 6],
        "explanation": "5 and 6 are correct since Paths must be created using the Paths.get() method. This method takes a varargs String parameter, so you can pass as many path segments to it as you like. 1 and 2 are incorrect because you cannot construct a Path directly. 3 and 4 are incorrect because the Files class works with Path objects but does not create them from Strings."
      },
      {
        "question_id": 6,
        "correct_answers": [1],
        "explanation": "1 is correct because it prints the path to get to two from one. 2 is incorrect because it prints out ../.. which is the path to navigate to one from two. This is the reverse of what we want. 3, 4, and 5 are incorrect because it does not make sense to call resolve with absolute paths. They might print out c:/x/c:/x/y/a, c:/x/y/a/c:/x, and c:/x/y/a/c:/x/y/a, respectively. 6 is incorrect because of the above. Note that the directory structure provided is redundant. Neither relativize() nor resolve() requires either path to actually exist. "
      },
      {
        "question_id": 7,
        "correct_answers": [5],
        "explanation": "5 is correct because a directory containing files or subdirectories is copied or moved in\nits entirety. Directories can only be deleted if they are empty. Trying to delete a nonempty directory will throw a DirectoryNotEmptyException. The question says \"usually\" because copy and move success depends on file permissions. Think about the most common cases when encountering words such as \"usually\" on the exam. 1, 2, 3, 4, 6, and 7 are incorrect because of the above."
      },
      {
        "question_id": 8,
        "correct_answers": [2],
        "explanation": "2 is correct because, like the Java 7 code, it returns false if the file does not exist. 1 is incorrect because this code throws an Exception if the file does not exist. 3, 4, 5, and 6 are incorrect because they do not compile. There is no deleteOnExit() method, and file operations such as delete occur using the Files class rather than the path object directly. "
      },
      {
        "question_id": 9,
        "correct_answers": [1, 2, 4],
        "explanation": "1, 2, and 4 are correct. Creation time is a basic attribute, which means you can read BasicFileAttributes or any of its subclasses to read it. DosFileAttributes is one such subclass. 3 is incorrect because you cannot cast a more general type to a more specific type. 5 is incorrect because this example specifies it is being run on Windows. While it would work on UNIX, it throws an UnsupportedOperationException on Windows due to requesting the WindowsFileSystemProvider to get a POSIX class. 6 and 7 are incorrect because those methods do not exist. You must use the Files class to get the attributes. "
      },
      {
        "question_id": 10,
        "correct_answers": [2, 3, 5],
        "explanation": "2, 3, and 5 are correct. BasicFileAttributes is the general superclass. DosFileAttributes subclasses BasicFileAttributes for Windows operating systems. PosixFileAttributes subclasses BasicFileAttributes for UNIX/Linux/Mac operating systems. 1, 4, and 6 are incorrect because no such classes exist. "
      },
      {
        "question_id": 11,
        "correct_answers": [2, 3],
        "explanation": "2 and 3 are correct because file visitor does a depth-first search. When files and directories are at the same level of the file tree, they can be visited in either order. Therefore, \"y\" and \"a\" could be reversed. All of the subdirectories and files are visited before postVisit is called on the directory. 1, 4, and 5 are incorrect because of the above. "
      },
      {
        "question_id": 12,
        "correct_answers": [5],
        "explanation": "5 is correct because it is the correct constant to end the FileVisitor. 2 is incorrect because END is not defined as a result constant. 1, 3, and 4 are incorrect.\nWhile they are valid constants, they do not end file visiting. CONTINUE proceeds as if nothing special has happened. SKIP_SUBTREE skips the subdirectory, which doesn't even make sense\nfor a Java file. SKIP_SIBLINGS would skip any files in the same directory. Since we weren't told what the file structure is, we can't assume there aren't other directories or subdirectories. Therefore, we have to choose the most general answer of TERMINATE. 6 is incorrect because file visitor throws a NullPointerException if null is returned as the result. "
      },
      {
        "question_id": 13,
        "correct_answers": [2],
        "explanation": "2 is correct. ** matches zero or more characters, including multiple directories. 1 is incorrect because */ only matches one directory. It will match \"temp\" but not \"c:/temp,\" let alone \"c:/temp/dir.\" 3 is incorrect because *.txt only matches filenames and not directory paths. 4, 5, and 6 are incorrect because the paths we want to match do not begin with a slash. 7 is incorrect because of the above. "
      },
      {
        "question_id": 14,
        "correct_answers": [3],
        "explanation": "3 is correct because DirectoryStream only looks at files in the immediate directory. **/*.txt means zero or more directories followed by a slash, followed by zero or more characters followed by .txt. Since the slash is in there, it is required to match, which makes it mean one or more directories. However, this is impossible because DirectoryStream only looks at one directory. If the expression were simply *.txt, answer 1 would be correct. 1, 2, 4, and 5 are incorrect because of the above. "
      },
      {
        "question_id": 15,
        "correct_answers": [1],
        "explanation": "1 is correct because watch service only looks at a single directory. If you want to look at subdirectories, you need to set recursive watch keys. This is usually done using a FileVisitor. 2, 3, 4, 5, and 6 are incorrect because of the above."
      }
    ]
  },
  {
    "exam_id": 2,
    "theme_id": 10,
    "theme_content": "Advanced OO and Design Patterns",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [3],
        "explanation": "3 is correct. Since A extends B, it IS-A B. Since C is an instance variable in A, A HAS-A C. 1, 2, 4, 5, and 6 are incorrect because of the above. "
      },
      {
        "question_id": 2,
        "correct_answers": [2],
        "explanation": "2 is correct. Method forwarding is an object composition principle and calls methods on an instance variable of an object. 1 is incorrect because method delegation and method forwarding are the same thing. 3 is incorrect because it is the singleton pattern that limits you to one object. 4 is incorrect because singleton classes typically don't have a superclass (other than Object). 5 is incorrect because there is no such requirement. "
      },
      {
        "question_id": 3,
        "correct_answers": [6],
        "explanation": "6 is correct. The singleton pattern is identifiable by the static variable for the single instance and the accessor returning it. 2 is incorrect because there is no interface. The class just happens to have methods update() and delete(), which are similar to those found in a DAO. 1, 3, 4, and 5 are incorrect because of the above. "
      },
      {
        "question_id": 4,
        "correct_answers": [4],
        "explanation": "4 is correct. The object composition principle of method forwarding is shown. 5 is tricky, but incorrect. Although getInstance() is a common name for a method in a singleton, the method doesn't return a static object. While it does create an object, it isn't a factory either, since there is no superclass. 1, 2, and 3 are incorrect because of the above."
      },
      {
        "question_id": 5,
        "correct_answers": [2],
        "explanation": "2 is correct. Class A is the object we are creating using the factory method. Class G is the abstract superclass for the factory. Not shown is a class implementing class G that actually creates the object. 1, 3, 4, and 5 are incorrect because of the above."
      },
      {
        "question_id": 6,
        "correct_answers": [3, 6],
        "explanation": "3 and 6 are correct. The factory design pattern creates new objects for each call, and the singleton design pattern creates one object, returning it each time. 1, 2, 4, and 5 are incorrect because of the above."
      },
      {
        "question_id": 7,
        "correct_answers": [1],
        "explanation": "1 is correct. The factory design pattern decouples the caller from the implementation class name. 2 is incorrect because that would be poor design. 3 is incorrect because it describes the singleton pattern. 4 is incorrect because it describes the DAO pattern. 5 is incorrect because of the above. "
      },
      {
        "question_id": 8,
        "correct_answers": [2],
        "explanation": "2 is correct. The Data Access Object pattern uses an interface so callers aren't dependent on a specific implementation class. 1, 3, 4, 5, and 6 are incorrect because of the above."
      },
      {
        "question_id": 9,
        "correct_answers": [1, 3],
        "explanation": "1 and 3 are correct. The DAO pattern centralizes logic for the data access code, making reuse easier and allowing you to switch out implementations. 2 is incorrect because you still have to code the DAO. 4 is incorrect because you call a DAO from your business object; you do not inherit from it. 5 is incorrect because you can have many DAO objects. "
      },
      {
        "question_id": 10,
        "correct_answers": [2, 3],
        "explanation": "2 and 3 are correct. Design patterns are conceptual and design level. You have to code the implementation for each use. 4 is incorrect because there are dozens of patterns defined for Java. Only three of them are tested on the exam, but you should be aware that more exist. 5 is incorrect because it makes sense to reuse the same pattern. For example, you might have multiple DAO objects. 1 and 6 are incorrect because of the above. "
      },
      {
        "question_id": 11,
        "correct_answers": [3],
        "explanation": "3 is correct. 1, 2, and 4 are incorrect. 1 refers to encapsulation, 2 refers to coupling, and 4 refers to polymorphism. "
      },
      {
        "question_id": 12,
        "correct_answers": [3],
        "explanation": "3 is correct. Generally speaking, public variables are a sign of weak encapsulation. 1, 2, 4, and 5 are incorrect because based on the information given, none of these statements can be supported."
      }
    ]
  },
  {
    "exam_id": 2,
    "theme_id": 11,
    "theme_content": "Generics and Collections",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [1],
        "explanation": "1 is correct. 2 is incorrect because List is an interface, so you can't say new List(), regardless of any generic types. 4, 5, and 6 are incorrect because List only takes one type parameter\n(a Map would take two, not a List). 3 is tempting, but incorrect. The type argument <List<Integer>\\> must be the same for both sides of the assignment, even though the constructor new ArrayList() on the right side is a subtype of the declared type List on the left. "
      },
      {
        "question_id": 2,
        "correct_answers": [2, 4],
        "explanation": "2 and 4. 2 is true because often two dissimilar objects can return the same hashcode value. 4 is true because if the hashCode() comparison returns ==, the two objects might or might not be equal. 1, 3, and 5 are incorrect. 3 is incorrect because the hashCode() method is very flexible in its return values, and often two dissimilar objects can return the same hashcode value. 1 and 5 are a negation of the hashCode() and equals() contract."
      },
      {
        "question_id": 3,
        "correct_answers": [5],
        "explanation": "5 is correct. You can't put both Strings and ints into the same TreeSet. Without generics, the compiler has no way of knowing what type is appropriate for this TreeSet,\nso it allows everything to compile. At runtime, the TreeSet will try to sort the elements\nas they're added, and when it tries to compare an Integer with a String, it will throw a ClassCastException. Note that although the before() method does not use generics, it does use autoboxing. Watch out for code that uses some new features and some old features mixed together. 1, 2, 3, and 4 are incorrect based on the above."
      },
      {
        "question_id": 4,
        "correct_answers": [3, 4],
        "explanation": "3 and 4 are correct. If hashCode() is not overridden, then every entry will go into its own bucket, and the overridden equals() method will have no effect on determining equivalency. If hashCode() is overridden, then the overridden equals() method will view t1 and t2 as duplicates. 1, 2, 5, and 6 are incorrect based on the above. "
      },
      {
        "question_id": 5,
        "correct_answers": [2, 5, 7],
        "explanation": "2, 5, and 7 are correct. 1 is incorrect because you can't use a primitive type as a type parameter. 3 is incorrect because a Map takes two type parameters separated by a comma. 4 is incorrect because an int can't autobox to a null, and 6 is incorrect because a null can't unbox to 0. 8 is incorrect because you can't autobox a primitive just by trying to invoke a method with it."
      },
      {
        "question_id": 6,
        "correct_answers": [2],
        "explanation": "2 is correct. The problem with the original code is that Sheep tries to implement Herbivore<Sheep> and Herbivore declares that its type parameter E can be any type that extends Plant. Since a Sheep is not a Plant, Herbivore<Sheep> makes no sense—the type Sheep is outside the allowed range of Herbivore's parameter E. Only solutions that either alter the definition of a Sheep or alter the definition of Herbivore will be able to fix this. So 1, 5, and 6 are eliminated. 2 works—changing the definition of an Herbivore to allow it to eat Sheep solves the problem. 3 doesn't work because an Herbivore<Plant> must have a munch(Plant) method, not munch(Grass). And 4 doesn't work, because in 4 we made Sheep extend Plant—now the Wolf class breaks because its munch(Sheep) method no longer fulfills the contract of Carnivore. "
      },
      {
        "question_id": 7,
        "correct_answers": [4],
        "explanation": "4 is correct. All of the collection classes allow you to grow or shrink the size of your collection. ArrayList provides an index to its elements. The newer collection classes tend not to have synchronized methods. Vector is an older implementation of ArrayList functionality and has synchronized methods; it is slower than ArrayList. 1, 2, 3, 5, and 6 are incorrect based on the logic described earlier. 3, List, is an interface, and 6, PriorityQueue, does not offer access by index. "
      },
      {
        "question_id": 8,
        "correct_answers": [2, 5, 6],
        "explanation": "2, 5, and 6 are correct. The return type of process is definitely declared as a List, not an ArrayList, so 1 and\n4 are incorrect. 3 is incorrect because the return type evaluates to List<Integer>, and that can't be assigned to a variable of type List<Number>. Of course, all these would probably cause a NullPointerException since the variables are still null—but the question only asked us to get the code to compile."
      },
      {
        "question_id": 9,
        "correct_answers": [2],
        "explanation": "2 is correct. For the sake of the exam, add() and offer() both add to (in this case) naturally sorted queues. The calls to poll() both return and then remove the first item from the queue, so the test fails. 1, 3, 4, 5, 6, 7, and 8 are incorrect based on the above."
      },
      {
        "question_id": 10,
        "correct_answers": [1, 2, 3, 4, 6],
        "explanation": "1, 2, 3, 4, and 6 are all correct. Only 5 is incorrect. Elements of a TreeSet must in some way implement Comparable."
      },
      {
        "question_id": 11,
        "correct_answers": [1, 4],
        "explanation": "1 and 4 are correct. While fragment II wouldn't fulfill the hashCode() contract (as you can see by the results), it is legal Java. For the purpose of the exam, if you don't override hashCode(), every object will have a unique hashcode. 2, 3, 5, and 6 are incorrect based on the above. "
      },
      {
        "question_id": 12,
        "correct_answers": [2, 6],
        "explanation": "2 and 6 are correct. After \"g\" is added, TreeSet s contains six elements and TreeSet subs contains three (b, c, d), because \"g\" is out of the range of subs. The first pollFirst() finds and removes only the \"a\". The second pollFirst() finds and removes the \"b\" from both TreeSets (remember they are backed). The final add() is in range of both TreeSets. The final contents are [c,c2,d,e,g] and [c,c2,d]. 1, 3, 4, 5, 7, and H are incorrect based on the above. "
      },
      {
        "question_id": 13,
        "correct_answers": [1],
        "explanation": "1 is correct. The ceilingKey() method's argument is inclusive. The floorKey() method would be used to find keys before the specified key. The firstKey() method's argument is also inclusive. 2, 3, 4, 5, and 6 are incorrect based on the above. "
      },
      {
        "question_id": 14,
        "correct_answers": [2],
        "explanation": "2 is correct. 1 is incorrect because polymorphic assignments don't apply to generic type parameters. 3 and 4 are incorrect because they don't follow basic polymorphism rules. "
      },
      {
        "question_id": 15,
        "correct_answers": [7],
        "explanation": "7 is correct. Class Dog needs to implement Comparable in order for a TreeSet (which keeps its elements sorted) to be able to contain Dog objects. 1, 2, 3, 4, 5, and 6 are incorrect based on the above. "
      },
      {
        "question_id": 16,
        "correct_answers": [4, 7],
        "explanation": "4 and 7 are correct. First, the compareTo() method will reverse the normal sort. Second, the sort() is valid. Third, the binarySearch() gives –1 because it needs to be invoked using the same Comparator (o) as was used to sort the array. Note that when the binarySearch() returns an \"undefined result,\" it doesn't officially have to be a –1, but it usually is, so if you selected only G, you get full credit! 1, 2, 3, 5, and 6 are incorrect based on the above."
      }
    ]
  },
  {
    "exam_id": 2,
    "theme_id": 12,
    "theme_content": "Inner Classes",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [2, 4],
        "explanation": "2 and 4 are correct. 2 is correct because a static nested class is not tied to an instance of the enclosing class, and thus can't access the nonstatic members of the class (just as a static method can't access nonstatic members of a class). 4 uses the correct syntax for instantiating a static nested class. 1 is incorrect because static nested classes do not need (and can't use) a reference to an instance of the enclosing class. 3 is incorrect because static nested classes can declare and define nonstatic members. 5 is wrong because... it just is. There's no rule that says an inner or nested class has to extend anything."
      },
      {
        "question_id": 2,
        "correct_answers": [2, 3],
        "explanation": "2 and 3 are correct. 2 is correct because anonymous inner classes are no different from any other class when it comes to polymorphism. That means you are always allowed to declare a reference variable of the superclass type and have that reference variable refer to an instance of a subclass type, which in this case is an anonymous subclass of Bar. Since Bar is a subclass of Boo, it all works. 3 uses correct syntax for creating an instance of Boo. 1 is incorrect because it passes an int to the Boo constructor, and there is no matching constructor in the Boo class. 4 is incorrect because it violates the rules of polymorphism; you cannot refer to a superclass type using a reference variable declared as the subclass type. The superclass doesn't have everything the subclass has. 5 uses incorrect syntax."
      },
      {
        "question_id": 3,
        "correct_answers": [2, 5],
        "explanation": "2 and 5 are correct. 2 is correct because a method-local inner class can be abstract, although it means a subclass of the inner class must be created if the abstract class is to be used (so an abstract method-local inner class is probably not useful). 5 is correct because a method-local inner class works like any other inner class—it has a special relationship to an instance of the enclosing class, thus it can access all members of the enclosing class. 1 is incorrect because a method-local inner class does not have to be declared final (although it is legal to do so). 3 and 4 are incorrect because a method-local inner class cannot be made public (remember—local variables can't be public) or static."
      },
      {
        "question_id": 4,
        "correct_answers": [7],
        "explanation": "7 is correct. This code would be legal if line 7 ended with a semicolon. Remember that line 3 is a statement that doesn't end until line 7, and a statement needs a closing semicolon! 1, 2, 3, 4, 5, and 6 are incorrect based on the program logic just described. If the semicolon were added at line 7, then answer 2 would be correct—the program would print true, the return from the equals() method overridden by the anonymous subclass of Object."
      },
      {
        "question_id": 5,
        "correct_answers": [5],
        "explanation": "5 is correct. If you use a reference variable of type Object, you can access only those members defined in class Object. 1, 2, 3, and 4 are incorrect based on the program logic just described."
      },
      {
        "question_id": 6,
        "correct_answers": [1],
        "explanation": "1 is correct. You can define an inner class as abstract, which means you can instantiate only concrete subclasses of the abstract inner class. The object referenced by the variable t is an instance of an anonymous subclass of AbstractTest, and the anonymous class overrides the getNum() method to return 22. The variable referenced by f is an instance of an anonymous subclass of Bar, and the anonymous Bar subclass also overrides the getNum() method to return 57. Remember that to create a Bar instance, we need an instance of the enclosing AbstractTest class to tie to the new Bar inner class instance. AbstractTest can't be instantiated because it's abstract, so we created an anonymous subclass (non-abstract) and then used the instance of that anonymous subclass to tie to the new Bar subclass instance. 2, 3, 4, and 5 are incorrect based on the program logic just described."
      },
      {
        "question_id": 7,
        "correct_answers": [4],
        "explanation": "4 is correct. It is the only code that uses the correct inner class instantiation syntax. 1, 2, 3, and 5 are incorrect based on the above text."
      },
      {
        "question_id": 8,
        "correct_answers": [3],
        "explanation": "3 is correct. The \"inner\" version of class A isn't used because its declaration comes after the instance of class A is created in the go() method. 1, 2, 4, and 5 are incorrect based on the above text."
      },
      {
        "question_id": 9,
        "correct_answers": [3, 7],
        "explanation": "3 and 7 are correct. 3 is the correct syntax to access an inner class's outer instance method from an initialization block, and 7 is the correct syntax to access it from a constructor. 1, 2, 4, 5, and 6 are incorrect based on the above text."
      },
      {
        "question_id": 10,
        "correct_answers": [3],
        "explanation": "3 is correct. The inner classes are valid, and all the methods (including main()), correctly throw an exception, given that doStuff() throws an exception. The doStuff() in class TimesSquare overrides class Manhattan's doStuff() and produces no output. 1, 2, 4, 5, 6, 7, and 8 are incorrect based on the above text."
      },
      {
        "question_id": 11,
        "correct_answers": [2],
        "explanation": "2 is correct. The inner class Gazer has access to Navel's private static and private instance variables. 1, 3, 4, 5, and 6 are incorrect based on the above text."
      },
      {
        "question_id": 12,
        "correct_answers": [1],
        "explanation": "1 is correct. The inner class Sorter must be declared static to be called from the static method main(). If Sorter had been static, answer 5 would be correct. 2, 3, 4, 5, and 6 are incorrect based on the above text."
      }
    ]
  },
  {
    "exam_id": 2,
    "theme_id": 13,
    "theme_content": "Threads",
    "questions": [
      {
        "question_id": 1,
        "correct_answers": [3],
        "explanation": "3 is correct. The class implements the Runnable interface with a legal run() method. 1 is incorrect because interfaces are implemented, not extended. 2 is incorrect because even though the class has a valid public void run() method, it does not implement the Runnable interface. 4 is incorrect because the run() method must be public. 5 is incorrect because the method to implement is run(), not start(). "
      },
      {
        "question_id": 2,
        "correct_answers": [4],
        "explanation": "4 is correct. The thread MyThread will start and loop three times (from 0 to 2). 1 is incorrect because the Thread class implements the Runnable interface; therefore,\nin line 6, Thread can take an object of type Thread as an argument in the constructor (this is NOT recommended). 2 and 3 are incorrect because the variable i in the for loop starts with a value of 0 and ends with a value of 2. 5 is incorrect based on the above. "
      },
      {
        "question_id": 3,
        "correct_answers": [4],
        "explanation": "4 is correct. The sleep() method must be enclosed in a try/catch block, or the method printAll() must declare it throws the InterruptedException. 5 is incorrect, but it would be correct if the InterruptedException was dealt with (1 is too precise). 2 is incorrect (even if the InterruptedException was dealt with) because all Java code, including the main() method, runs in threads. 3 is incorrect. The sleep() method is static; it always affects the currently executing thread. "
      },
      {
        "question_id": 4,
        "correct_answers": [2, 6],
        "explanation": "2 and 6 are correct. By marking the methods as synchronized, the threads will get the lock of the this object before proceeding. Only one thread will be setting or reading at any given moment, thereby assuring that read() always returns the addition of a valid pair. 1 is incorrect because it is not synchronized; therefore, there is no guarantee that the values added by the read() method belong to the same pair. 3 and 4 are incorrect; only objects can be used to synchronize on. 5 is incorrect because it fails—it is not possible to select other objects (even this) to synchronize on when declaring a method as synchronized."
      },
      {
        "question_id": 5,
        "correct_answers": [4],
        "explanation": "4 is correct. 1 and 2 will be printed, but there will be no return from the wait call because no other thread will notify the main thread, so 3 will never be printed. It's frozen at line 7. 1 is incorrect; IllegalMonitorStateException is an unchecked exception. 2 and 3 are incorrect; 3 will never be printed, since this program will wait forever. 5 is incorrect because IllegalMonitorStateException will never be thrown because the wait() is done on args within a block of code synchronized on args. 6 is incorrect because any object can be used to synchronize on, and this and static don't mix. "
      },
      {
        "question_id": 6,
        "correct_answers": [1],
        "explanation": "1 is correct. Either of the two events will make the thread a candidate for running again. 2 is incorrect because a waiting thread will not return to runnable when the lock is released unless a notification occurs. 3 is incorrect because the thread will become a candidate immediately after notification. 4 is also incorrect because a thread will not come out of a waiting pool just because a lock has been released. "
      },
      {
        "question_id": 7,
        "correct_answers": [1, 4],
        "explanation": "1 is correct because notifyAll() (and wait() and notify()) must be called from within a synchronized context. 4 is a correct statement. 2 is incorrect because to call wait(), the thread must own the lock on the object that wait() is being invoked on, not the other way around. 3 is incorrect because notify() is defined in java.lang.Object. 5 is incorrect because notify() will not cause a thread to release its locks. The thread can only release its locks by exiting the synchronized code. 6 is incorrect because notifyAll() notifies all the threads waiting on a particular locked object, not all threads waiting on any object."
      },
      {
        "question_id": 8,
        "correct_answers": [5],
        "explanation": "5 is correct. Synchronizing the public methods is sufficient to make this safe, so 6 is incorrect. This class is not thread-safe unless some sort of synchronization protects the changing data. 2 is incorrect because although a StringBuffer is synchronized internally, we call append() multiple times, and nothing would prevent two simultaneous log() calls from mixing up their messages. 3 and 4 are incorrect because if one method remains unsynchronized, it can run while the other is executing, which could result in reading the contents while one of the messages is incomplete, or worse. (You don't want to call toString() on the StringBuffer as it's resizing its internal character array.)"
      },
      {
        "question_id": 9,
        "correct_answers": [7],
        "explanation": "7 is correct. The code does not acquire a lock on t before calling t.wait(), so it throws an IllegalMonitorStateException. The method is synchronized, but it's not synchronized on t so the exception will be thrown. If the wait were placed inside a synchronized(t) block, then 4 would be correct. 1, 2, 3, 4, 5, and 6 are incorrect based on the logic described above."
      },
      {
        "question_id": 10,
        "correct_answers": [2],
        "explanation": "2 is correct. In the first line of main we're constructing an instance of an anonymous inner class extending from MyThread. So the MyThread constructor runs and prints MyThread. Next, main() invokes start() on the new thread instance, which causes the overridden run() method (the run() method in the anonymous inner class) to be invoked. 1, 3, 4, 5, 6, 7, and 8 are incorrect based on the logic described above."
      },
      {
        "question_id": 11,
        "correct_answers": [1, 6, 8],
        "explanation": "1, 6, and 8 are correct. 1 is correct because when synchronized instance methods are called on the same instance, they block each other. 6 and 8 can't happen because synchronized static methods in the same class block each other, regardless of which instance was used to call the methods. (An instance is not required to call static methods; only the class.) 3, although incorrect, could happen because synchronized instance methods called on different instances do not block each other. 2, 4, 5, and 7 are incorrect but also could all happen because instance methods and static methods lock on different objects, and do not block each other. "
      },
      {
        "question_id": 12,
        "correct_answers": [1, 3, 4, 5, 6],
        "explanation": "1, 3, 4, 5, and 6 are correct. This may look like laurel and hardy are battling to cause the other to sleep() or wait()—but that's not the case. Since sleep() is a static method, it affects the current thread, which is laurel (even though the method is invoked using a reference to hardy). That's misleading, but perfectly legal, and the Thread laurel is able\nto sleep with no exception, printing 1 and 3 (after at least a one-second delay). Meanwhile, hardy tries to call laurel.wait()—but hardy has not synchronized on laurel, so calling laurel.wait() immediately causes an IllegalMonitorStateException, and so hardy prints 4, 5, and 6. Although the order of the output is somewhat indeterminate (we have no way of knowing whether 1 is printed before 4, for example), it is guaranteed that 1, 3, 4, 5, and 6 will all be printed in some order, eventually—so G is incorrect. 2, 7, and 8 are incorrect based on the above."
      },
      {
        "question_id": 13,
        "correct_answers": [3, 4],
        "explanation": "3 and 4 are correct. Fragment I doesn't start a new thread. Fragment II doesn't compile. Fragment III creates a new thread but doesn't start it. Fragment IV creates a new thread and invokes run() directly, but it doesn't start the new thread. Fragment V creates and starts a new thread. 1, 2, 5, 6, and 7 are incorrect based on the above. "
      },
      {
        "question_id": 14,
        "correct_answers": [1],
        "explanation": "1 is correct. The join() must be placed in a try/catch block. If it were, answers 2 and 4 would be correct. The join() causes the main thread to pause and join the end of the other thread, meaning \"m2\" must come last. 2, 3, 4, 5, and 6 are incorrect based on the above."
      },
      {
        "question_id": 15,
        "correct_answers": [6],
        "explanation": "6 is correct. With Fragment I, the chat method is synchronized, so the two threads can't swap back and forth. With either fragment, the first output must be yo. 1, 2, 3, 4, and 5 are incorrect based on the above. "
      },
      {
        "question_id": 16,
        "correct_answers": [6],
        "explanation": "6 is correct. When run() is invoked, it is with a new instance of ChicksYack and c has not been assigned to an object. If c were static, then because yack is synchronized, answers 3 and 5 would have been correct. 1, 2, 3, 4, and 5 are incorrect based on the above. "
      },
      {
        "question_id": 17,
        "correct_answers": [3, 5],
        "explanation": "3 and 5 are correct. 5 should be obvious. 3 is correct because even though move() is synchronized, it's being invoked on two different objects. 1, 2, and 4 are incorrect based on the above."
      }
    ]
  },
  {
    "exam_id": 2,
    "theme_id": 14,
    "theme_content": "Concurrency",
    "questions": [
    ]
  },
  {
    "exam_id": 2,
    "theme_id": 15,
    "theme_content": "JDBC",
    "questions": [
    ]
  }
]
